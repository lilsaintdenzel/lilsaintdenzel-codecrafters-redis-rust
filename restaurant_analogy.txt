Redis Server Implementation - Restaurant Analogy Explanation

This Redis server works like a smart restaurant system that can handle multiple customers simultaneously and remember their orders even after closing!

=== COMPLETE CODE WITH RESTAURANT ANALOGIES ===

```rust
#![allow(unused_imports)]
use std::collections::HashMap;  // The restaurant's order book
use std::env;                   // Reading the restaurant's opening instructions
use std::fs::File;              // Reading the restaurant's recipe book from storage
use std::io::{BufReader, Read, Write}; // Taking orders and serving customers
use std::net::TcpListener;      // The restaurant's front door
use std::path::Path;            // Finding where recipe books are stored
use std::sync::{Arc, Mutex};    // Safe way to share the order book between waiters
use std::thread;                // Restaurant waiters (each customer gets their own waiter)
use std::time::{SystemTime, UNIX_EPOCH}; // Restaurant's clock for timing special orders

// A dish order with an optional expiration time (like daily specials)
#[derive(Clone)]
struct StoredValue {
    value: String,              // The dish/order details
    expires_at: Option<u128>,   // When this special offer expires (restaurant time)
}

// Restaurant configuration - where to store recipes and which location to operate
#[derive(Clone)]
struct Config {
    dir: String,                // Kitchen storage directory for recipe books
    dbfilename: String,         // Recipe book filename
    port: u16,                  // Restaurant location/address
    replicaof: Option<(String, u16)>, // If this is a franchise, connect to headquarters (host, port)
}

// Waiter training: How to understand customer requests in restaurant lingo
fn parse_redis_command(buffer: &[u8], n: usize) -> Option<Vec<String>> {
    let data = String::from_utf8_lossy(&buffer[..n]);
    let lines: Vec<&str> = data.split("\r\n").collect();
    
    // Check if it's a proper order format (*number means "order has X parts")
    if lines.is_empty() || !lines[0].starts_with('*') {
        return None; // Can't understand this order
    }
    
    let array_len: usize = lines[0][1..].parse().ok()?; // How many parts in this order?
    let mut args = Vec::new(); // Collect order details here
    let mut line_idx = 1;
    
    // Parse each part of the order
    for _ in 0..array_len {
        // Each part starts with $ and length ($4 means "next item is 4 letters")
        if line_idx >= lines.len() || !lines[line_idx].starts_with('$') {
            return None; // Malformed order
        }
        
        let str_len: usize = lines[line_idx][1..].parse().ok()?; // How long is this item?
        line_idx += 1;
        
        // Get the actual order item
        if line_idx >= lines.len() {
            return None;
        }
        
        let arg = lines[line_idx].to_string();
        if arg.len() != str_len {
            return None; // Length doesn't match what was promised
        }
        
        args.push(arg); // Add this item to the order
        line_idx += 1;
    }
    
    Some(args) // Return the complete understood order
}

// Recipe book decoder: How to read the restaurant's special encoding system
fn parse_length_encoding(bytes: &[u8], pos: &mut usize) -> Option<u64> {
    if *pos >= bytes.len() {
        return None;
    }
    
    let first_byte = bytes[*pos];
    *pos += 1;
    
    // First two bits tell us what encoding system the chef used
    let first_two_bits = (first_byte & 0b11000000) >> 6;
    
    match first_two_bits {
        0b00 => {
            // Small recipe: remaining 6 bits tell us the size
            Some((first_byte & 0b00111111) as u64)
        }
        0b01 => {
            // Medium recipe: combine this byte + next byte for size
            if *pos >= bytes.len() {
                return None;
            }
            let second_byte = bytes[*pos];
            *pos += 1;
            let length = (((first_byte & 0b00111111) as u64) << 8) | (second_byte as u64);
            Some(length)
        }
        0b10 => {
            // Large recipe: next 4 bytes tell us the size (big recipes!)
            if *pos + 4 > bytes.len() {
                return None;
            }
            let mut length = 0u64;
            for i in 0..4 {
                length = (length << 8) | (bytes[*pos + i] as u64);
            }
            *pos += 4;
            Some(length)
        }
        0b11 => {
            // Special encoding - like "this recipe is stored in shorthand"
            Some(0xFF00 | ((first_byte & 0b00111111) as u64))
        }
        _ => None,
    }
}

// Recipe text decoder: How to read ingredients and instructions from the recipe book
fn parse_string_encoding(bytes: &[u8], pos: &mut usize) -> Option<String> {
    let length_or_type = parse_length_encoding(bytes, pos)?;
    
    if length_or_type >= 0xFF00 {
        // Special shorthand - numbers stored as symbols instead of words
        let encoding_type = (length_or_type & 0xFF) as u8;
        match encoding_type {
            0x00 => {
                // Small number (like "2 cups")
                if *pos >= bytes.len() {
                    return None;
                }
                let val = bytes[*pos] as i8;
                *pos += 1;
                Some(val.to_string())
            }
            0x01 => {
                // Medium number (like "16 ounces")
                if *pos + 2 > bytes.len() {
                    return None;
                }
                let val = u16::from_le_bytes([bytes[*pos], bytes[*pos + 1]]) as i16;
                *pos += 2;
                Some(val.to_string())
            }
            0x02 => {
                // Large number (like "3200 calories")
                if *pos + 4 > bytes.len() {
                    return None;
                }
                let val = u32::from_le_bytes([
                    bytes[*pos],
                    bytes[*pos + 1],
                    bytes[*pos + 2],
                    bytes[*pos + 3],
                ]) as i32;
                *pos += 4;
                Some(val.to_string())
            }
            _ => None,
        }
    } else {
        // Regular text: read the specified number of characters
        let len = length_or_type as usize;
        if *pos + len > bytes.len() {
            return None;
        }
        let string_bytes = &bytes[*pos..*pos + len];
        *pos += len;
        String::from_utf8(string_bytes.to_vec()).ok()
    }
}

// Menu search helper: Does this dish match what the customer is looking for?
fn matches_pattern(key: &str, pattern: &str) -> bool {
    if pattern == "*" {
        return true; // "*" means "show me everything on the menu"
    }
    
    // Simple menu pattern matching
    if pattern.contains('*') {
        if pattern == "*" {
            return true;
        }
        // More complex search patterns could be added here
        true
    } else {
        key == pattern // Exact dish name match only
    }
}

// Restaurant opening: Read the stored recipe book when opening for business
fn load_rdb_file(config: &Config) -> HashMap<String, StoredValue> {
    let mut data_store = HashMap::new();
    let rdb_path = Path::new(&config.dir).join(&config.dbfilename);
    
    // Check if recipe book exists (restaurant might be brand new)
    if !rdb_path.exists() {
        return data_store; // Empty menu for new restaurant
    }
    
    // Try to open the recipe book
    let file = match File::open(&rdb_path) {
        Ok(f) => f,
        Err(_) => return data_store, // Couldn't read recipes, start with empty menu
    };
    
    // Read the entire recipe book
    let mut reader = BufReader::new(file);
    let mut buffer = Vec::new();
    if reader.read_to_end(&mut buffer).is_err() {
        return data_store; // Recipe book damaged, start fresh
    }
    
    let mut pos = 0;
    
    // Check recipe book header - should start with "REDIS" (Restaurant Electronic Data Info System)
    if buffer.len() < 9 || &buffer[0..5] != b"REDIS" {
        return data_store; // Not a valid recipe book
    }
    pos = 9; // Skip the header stamp
    
    // Read through all the recipes section by section
    while pos < buffer.len() {
        let opcode = buffer[pos]; // What type of section is this?
        pos += 1;
        
        match opcode {
            0xFA => {
                // Restaurant info section (like "established 1985") - skip for now
                if let Some(_key) = parse_string_encoding(&buffer, &mut pos) {
                    let _value = parse_string_encoding(&buffer, &mut pos);
                }
            }
            0xFE => {
                // Menu section marker (like "APPETIZERS" or "MAIN COURSES")
                let _db_index = parse_length_encoding(&buffer, &mut pos);
            }
            0xFB => {
                // Menu organization info - skip
                let _hash_table_size = parse_length_encoding(&buffer, &mut pos);
                let _expire_hash_table_size = parse_length_encoding(&buffer, &mut pos);
            }
            0xFC => {
                // Recipe with precise expiration (like "fresh until 2:30 PM")
                if pos + 8 > buffer.len() {
                    break;
                }
                // Read 8-byte expiration time stamp
                let expire_timestamp = u64::from_le_bytes([
                    buffer[pos],
                    buffer[pos + 1],
                    buffer[pos + 2],
                    buffer[pos + 3],
                    buffer[pos + 4],
                    buffer[pos + 5],
                    buffer[pos + 6],
                    buffer[pos + 7],
                ]) as u128;
                pos += 8;
                
                // Skip dish type marker
                if pos >= buffer.len() {
                    break;
                }
                let _value_type = buffer[pos];
                pos += 1;
                
                // Read dish name and recipe
                if let Some(key) = parse_string_encoding(&buffer, &mut pos) {
                    if let Some(value) = parse_string_encoding(&buffer, &mut pos) {
                        data_store.insert(
                            key,
                            StoredValue {
                                value,
                                expires_at: Some(expire_timestamp),
                            },
                        );
                    }
                }
            }
            0xFD => {
                // Recipe with day-based expiration (like "good until tomorrow")
                if pos + 4 > buffer.len() {
                    break;
                }
                // Read 4-byte day stamp and convert to precise time
                let expire_timestamp = u32::from_le_bytes([
                    buffer[pos],
                    buffer[pos + 1],
                    buffer[pos + 2],
                    buffer[pos + 3],
                ]) as u128
                    * 1000; // Convert days to precise time
                pos += 4;
                
                // Skip dish type marker
                if pos >= buffer.len() {
                    break;
                }
                let _value_type = buffer[pos];
                pos += 1;
                
                // Read dish name and recipe
                if let Some(key) = parse_string_encoding(&buffer, &mut pos) {
                    if let Some(value) = parse_string_encoding(&buffer, &mut pos) {
                        data_store.insert(
                            key,
                            StoredValue {
                                value,
                                expires_at: Some(expire_timestamp),
                            },
                        );
                    }
                }
            }
            0xFF => {
                // End of recipe book marker
                break;
            }
            _ => {
                // Regular recipe (always available, like house specials)
                let _value_type = opcode;
                
                // Read dish name and recipe
                if let Some(key) = parse_string_encoding(&buffer, &mut pos) {
                    if let Some(value) = parse_string_encoding(&buffer, &mut pos) {
                        data_store.insert(
                            key,
                            StoredValue {
                                value,
                                expires_at: None,
                            },
                        );
                    }
                }
            }
        }
    }
    
    data_store // Return the restored menu
}

// Restaurant setup: Read management instructions from the opening checklist
fn parse_args() -> Config {
    let args: Vec<String> = env::args().collect();
    
    // Default restaurant setup
    let mut dir = "/tmp/redis-data".to_string(); // Default kitchen storage
    let mut dbfilename = "dump.rdb".to_string(); // Default recipe book name
    let mut port = 6379u16; // Default restaurant location (address 6379)
    let mut replicaof = None; // Default: independent restaurant (not a franchise)
    
    let mut i = 1;
    while i < args.len() {
        // Read management instructions
        match args[i].as_str() {
            "--dir" => {
                // "Store recipe books in this kitchen location"
                if i + 1 < args.len() {
                    dir = args[i + 1].clone();
                    i += 2;
                } else {
                    i += 1;
                }
            }
            "--dbfilename" => {
                // "Name the recipe book this"
                if i + 1 < args.len() {
                    dbfilename = args[i + 1].clone();
                    i += 2;
                } else {
                    i += 1;
                }
            }
            "--port" => {
                // "Open the restaurant at this address/location"
                if i + 1 < args.len() {
                    if let Ok(parsed_port) = args[i + 1].parse::<u16>() {
                        port = parsed_port; // Use custom location if valid
                    }
                    i += 2;
                } else {
                    i += 1;
                }
            }
            "--replicaof" => {
                // "Operate as a franchise restaurant, reporting to headquarters"
                if i + 1 < args.len() {
                    let master_info = &args[i + 1];
                    let parts: Vec<&str> = master_info.split_whitespace().collect();
                    if parts.len() == 2 {
                        if let Ok(master_port) = parts[1].parse::<u16>() {
                            replicaof = Some((parts[0].to_string(), master_port));
                        }
                    }
                    i += 2;
                } else {
                    i += 1;
                }
            }
            _ => {
                i += 1;
            }
        }
    }
    
    Config { dir, dbfilename, port, replicaof } // Return restaurant configuration
}

// Main restaurant operations
fn main() {
    // Read management instructions and set up restaurant configuration
    let config = parse_args();
    let bind_address = format!("127.0.0.1:{}", config.port);
    let listener = TcpListener::bind(&bind_address).unwrap();
    
    // Load existing menu from recipe book (if it exists)
    let initial_data = load_rdb_file(&config);
    
    // Create the restaurant's shared order book (thread-safe for all waiters)
    let data_store = Arc::new(Mutex::new(initial_data));

    // Open the restaurant and wait for customers
    for stream in listener.incoming() {
        match stream {
            Ok(mut stream) => {
                // Give each waiter access to the shared order book and restaurant info
                let store_clone = Arc::clone(&data_store);
                let config_clone = config.clone();
                
                // Assign a dedicated waiter to this customer
                thread::spawn(move || {
                    let mut buffer = [0; 1024]; // Waiter's notepad for taking orders
                    
                    // Keep serving this customer
                    loop {
                        match stream.read(&mut buffer) {
                            Ok(0) => break, // Customer left the restaurant
                            Ok(n) => {
                                // Try to understand the customer's order using waiter training
                                if let Some(args) = parse_redis_command(&buffer, n) {
                                    if !args.is_empty() {
                                        let command = args[0].to_uppercase(); // Orders are case-insensitive
                                        
                                        // Provide service based on what the customer ordered
                                        match command.as_str() {
                                            "PING" => {
                                                // Customer just wants to know if we're open: "Are you there?"
                                                stream.write_all(b"+PONG\r\n").unwrap(); // "Yes, we're here!"
                                            }
                                            "ECHO" => {
                                                // Customer wants confirmation: "Did you hear me say 'hello'?"
                                                if args.len() > 1 {
                                                    let arg = &args[1];
                                                    let response = format!("${}\r\n{}\r\n", arg.len(), arg);
                                                    stream.write_all(response.as_bytes()).unwrap(); // "Yes, I heard 'hello'"
                                                }
                                            }
                                            "SET" => {
                                                // Customer wants to place an order: "SET burger well-done" or "SET soup hot px 300000"
                                                if args.len() >= 3 {
                                                    let key = &args[1]; // Dish name
                                                    let value = &args[2]; // Special instructions
                                                    let mut expires_at = None;
                                                    
                                                    // Check if customer wants timed service: "px 300000" means "serve within 5 minutes"
                                                    if args.len() >= 5 {
                                                        let option = args[3].to_uppercase();
                                                        if option == "PX" {
                                                            if let Ok(ms) = args[4].parse::<u128>() {
                                                                // Set kitchen timer: current time + service window
                                                                let now = SystemTime::now()
                                                                    .duration_since(UNIX_EPOCH)
                                                                    .unwrap()
                                                                    .as_millis();
                                                                expires_at = Some(now + ms);
                                                            }
                                                        }
                                                    }
                                                    
                                                    // Create order ticket with details and optional timer
                                                    let stored_value = StoredValue {
                                                        value: value.clone(),
                                                        expires_at,
                                                    };
                                                    
                                                    // Add order to the restaurant's order book
                                                    let mut store = store_clone.lock().unwrap();
                                                    store.insert(key.clone(), stored_value);
                                                    stream.write_all(b"+OK\r\n").unwrap(); // "Order taken!"
                                                }
                                            }
                                            "GET" => {
                                                // Customer asking about their order: "GET burger" (is my burger ready?)
                                                if args.len() >= 2 {
                                                    let key = &args[1]; // Which dish?
                                                    let mut store = store_clone.lock().unwrap();
                                                    
                                                    match store.get(key) {
                                                        Some(stored_value) => {
                                                            // Check if this order has expired (missed the service window)
                                                            if let Some(expires_at) = stored_value.expires_at {
                                                                let now = SystemTime::now()
                                                                    .duration_since(UNIX_EPOCH)
                                                                    .unwrap()
                                                                    .as_millis();
                                                                
                                                                if now >= expires_at {
                                                                    // Order expired! Remove it and say "sorry, we missed the deadline"
                                                                    store.remove(key);
                                                                    stream.write_all(b"$-1\r\n").unwrap(); // "Order cancelled"
                                                                } else {
                                                                    // Order is still good! Serve it
                                                                    let response = format!("${}\r\n{}\r\n", stored_value.value.len(), stored_value.value);
                                                                    stream.write_all(response.as_bytes()).unwrap(); // "Here's your dish!"
                                                                }
                                                            } else {
                                                                // No timer, regular order - serve it
                                                                let response = format!("${}\r\n{}\r\n", stored_value.value.len(), stored_value.value);
                                                                stream.write_all(response.as_bytes()).unwrap(); // "Here's your dish!"
                                                            }
                                                        }
                                                        None => {
                                                            // No such order exists
                                                            stream.write_all(b"$-1\r\n").unwrap(); // "We don't have that order"
                                                        }
                                                    }
                                                }
                                            }
                                            "CONFIG" => {
                                                // Customer asking about restaurant setup: "CONFIG GET dir" (where's your kitchen?)
                                                if args.len() >= 3 && args[1].to_uppercase() == "GET" {
                                                    let param = &args[2];
                                                    match param.to_lowercase().as_str() {
                                                        "dir" => {
                                                            // "Where do you store your recipes?"
                                                            let response = format!("*2\r\n$3\r\ndir\r\n${}\r\n{}\r\n", 
                                                                config_clone.dir.len(), config_clone.dir);
                                                            stream.write_all(response.as_bytes()).unwrap();
                                                        }
                                                        "dbfilename" => {
                                                            // "What's your recipe book called?"
                                                            let response = format!("*2\r\n$10\r\ndbfilename\r\n${}\r\n{}\r\n", 
                                                                config_clone.dbfilename.len(), config_clone.dbfilename);
                                                            stream.write_all(response.as_bytes()).unwrap();
                                                        }
                                                        _ => {
                                                            // "Don't know that information"
                                                            stream.write_all(b"*0\r\n").unwrap();
                                                        }
                                                    }
                                                }
                                            }
                                            "KEYS" => {
                                                // Customer wants to see the menu: "KEYS *" (what dishes do you have?)
                                                if args.len() >= 2 {
                                                    let pattern = &args[1]; // What kind of dishes? (* = all)
                                                    let store = store_clone.lock().unwrap();
                                                    let now = SystemTime::now()
                                                        .duration_since(UNIX_EPOCH)
                                                        .unwrap()
                                                        .as_millis();
                                                    
                                                    let mut matching_keys = Vec::new();
                                                    
                                                    // Look through all current orders/dishes
                                                    for (key, stored_value) in store.iter() {
                                                        // Check if this order has expired
                                                        let is_expired = if let Some(expires_at) = stored_value.expires_at {
                                                            now >= expires_at
                                                        } else {
                                                            false
                                                        };
                                                        
                                                        // Add to menu if not expired and matches what they're looking for
                                                        if !is_expired && matches_pattern(key, pattern) {
                                                            matching_keys.push(key.clone());
                                                        }
                                                    }
                                                    
                                                    // Present the menu list
                                                    let mut response = format!("*{}\r\n", matching_keys.len());
                                                    for key in matching_keys {
                                                        response.push_str(&format!("${}\r\n{}\r\n", key.len(), key));
                                                    }
                                                    stream.write_all(response.as_bytes()).unwrap(); // "Here's our current menu"
                                                } else {
                                                    // No menu request specifics, show empty menu
                                                    stream.write_all(b"*0\r\n").unwrap();
                                                }
                                            }
                                            "INFO" => {
                                                // Customer asking about restaurant status: "INFO replication"
                                                if args.len() >= 2 && args[1].to_lowercase() == "replication" {
                                                    // Tell them what kind of restaurant this is
                                                    let role = if config_clone.replicaof.is_some() {
                                                        "slave"  // This is a franchise restaurant
                                                    } else {
                                                        "master" // This is an independent restaurant
                                                    };
                                                    
                                                    let mut info_lines = vec![format!("role:{}", role)];
                                                    
                                                    // Add headquarters tracking info for independent restaurants
                                                    if config_clone.replicaof.is_none() {
                                                        // Restaurant ID (unique identifier like "Restaurant License #8371b4fb...")
                                                        info_lines.push("master_replid:8371b4fb1155b71f4a04d3e1bc3e18c4a990aeeb".to_string());
                                                        // Order tracking number (how many orders processed since opening)
                                                        info_lines.push("master_repl_offset:0".to_string());
                                                    }
                                                    
                                                    // Combine all status info
                                                    let info_response = info_lines.join("\r\n");
                                                    let response = format!("${}\r\n{}\r\n", info_response.len(), info_response);
                                                    stream.write_all(response.as_bytes()).unwrap(); // "Here's our restaurant info"
                                                }
                                            }
                                            _ => {
                                                // Customer said something we don't understand, just be friendly
                                                stream.write_all(b"+PONG\r\n").unwrap(); // "I'm here to help!"
                                            }
                                        }
                                    }
                                } else {
                                    // Couldn't understand the customer, just be friendly
                                    stream.write_all(b"+PONG\r\n").unwrap(); // "I'm here to help!"
                                }
                            }
                            Err(e) => {
                                // Something went wrong with this customer
                                println!("error reading from stream: {}", e);
                                break; // Stop serving this customer
                            }
                        }
                    }
                });
            }
            Err(e) => {
                // Someone tried to enter but couldn't get in
                println!("error: {}", e);
            }
        }
    }
}
```

=== KEY RESTAURANT FEATURES ===

**1. Multi-Waiter System (Multi-threading)**
- Restaurant manager listens for new customers at the front door
- Each customer gets their own dedicated waiter (thread)
- All waiters share the same order book safely using special coordination
- Multiple customers can be served simultaneously without waiting

**2. Customer Order Language (Redis RESP Protocol)**
- Waiters are trained to understand the restaurant's special ordering format
- Orders like: `*2\r\n$3\r\nSET\r\n$6\r\nburger\r\n` mean "I want to SET an order for a burger"
- Properly handles all customer communication with length checking
- Graceful handling of customers who speak unclearly

**3. Order Management with Timing (Data Storage with TTL)**
- Each order can have special timing requirements (like "serve within 5 minutes")
- Restaurant clock tracks all timing precisely down to the millisecond
- Automatic order cleanup when deadlines are missed
- Efficient order book organization using the restaurant's filing system

**4. Recipe Book System (RDB Persistence)**
- Restaurant can save and restore its complete menu from storage
- Handles complex recipe encoding systems from the chef
- Supports both daily specials with expiration and permanent menu items
- Graceful recovery if recipe books are damaged or missing
- Automatic menu restoration when restaurant reopens

**5. Restaurant Type Management (Replication Roles)**
- Independent restaurants vs. franchise locations determined by setup
- INFO requests tell customers what type of restaurant this is
- Independent restaurants provide:
  - `master_replid`: Restaurant license number (40-character unique ID)
  - `master_repl_offset`: Order counter (how many orders processed, starts at 0)
- Franchise restaurants report only their basic role information

**6. Service Menu (Command Implementation)**
- **PING**: "Are you open?" → "Yes, we're here!" (connectivity check)
- **ECHO**: "Did you hear me say X?" → "Yes, I heard X" (confirmation)
- **SET/GET**: Order placement and retrieval with optional timing windows
- **CONFIG GET**: Questions about restaurant setup and kitchen location
- **KEYS**: "What's on the menu?" with search capabilities
- **INFO**: Restaurant status, type, and tracking information

**7. Restaurant Setup System (Configuration)**
- Management can specify kitchen storage location, recipe book names
- Configurable restaurant address/location (port number)
- Franchise setup with headquarters connection information
- Default values for all restaurant settings

**8. Customer Service Excellence (Error Handling)**
- Friendly responses even when orders are unclear
- Default helpful attitude for unknown requests
- Proper handling of kitchen problems and storage issues
- Safe coordination between all waiters to prevent order mix-ups

**9. Efficient Operations (Performance)**
- Instant order lookups in the restaurant's filing system
- Quick waiter coordination with minimal delays
- One-waiter-per-customer model for personal service
- Smart memory management for busy restaurant operations

**10. Industry Standards (Protocol Compliance)**
- Uses standard restaurant communication format
- Proper order formatting and response structure
- Compatible with standard restaurant management systems
- Professional service standards throughout

This restaurant system provides excellent customer service with proper franchise management support, recipe persistence, and multi-customer handling capabilities!