Redis Server Implementation - Restaurant Analogy Explanation

This Redis server works like a smart restaurant system that can handle multiple customers simultaneously and remember their orders even after closing!

**NEW: Franchise Order Tracking System**
The restaurant now features advanced franchise tracking! When operating as a franchise location, the restaurant:
- Connects to headquarters and receives training materials (RDB file)
- Tracks every single instruction received from headquarters with precise byte counting
- Responds to headquarters' "How much have you processed?" (REPLCONF GETACK) with exact progress reports
- Maintains perfect synchronization by counting all communication bytes, not just food orders

=== COMPLETE CODE WITH RESTAURANT ANALOGIES ===

```rust
#![allow(unused_imports)]
use std::collections::HashMap;  // The restaurant's order book
use std::env;                   // Reading the restaurant's opening instructions
use std::fs::File;              // Reading the restaurant's recipe book from storage
use std::io::{BufReader, Read, Write}; // Taking orders and serving customers
use std::net::{TcpListener, TcpStream}; // The restaurant's front door and connections to headquarters
use std::path::Path;            // Finding where recipe books are stored
use std::sync::{Arc, Mutex};    // Safe way to share the order book between waiters
use std::thread;                // Restaurant waiters (each customer gets their own waiter)
use std::time::{SystemTime, UNIX_EPOCH}; // Restaurant's clock for timing special orders

// A dish order with an optional expiration time (like daily specials)
#[derive(Clone)]
struct StoredValue {
    value: String,              // The dish/order details
    expires_at: Option<u128>,   // When this special offer expires (restaurant time)
}

// Restaurant configuration - where to store recipes and which location to operate
#[derive(Clone)]
struct Config {
    dir: String,                // Kitchen storage directory for recipe books
    dbfilename: String,         // Recipe book filename
    port: u16,                  // Restaurant location/address
    replicaof: Option<(String, u16)>, // If this is a franchise, connect to headquarters (host, port)
}

// Waiter training: How to understand customer requests in restaurant lingo
fn parse_redis_command(buffer: &[u8], n: usize) -> Option<Vec<String>> {
    let data = String::from_utf8_lossy(&buffer[..n]);
    let lines: Vec<&str> = data.split("\r\n").collect();
    
    // Check if it's a proper order format (*number means "order has X parts")
    if lines.is_empty() || !lines[0].starts_with('*') {
        return None; // Can't understand this order
    }
    
    let array_len: usize = lines[0][1..].parse().ok()?; // How many parts in this order?
    let mut args = Vec::new(); // Collect order details here
    let mut line_idx = 1;
    
    // Parse each part of the order
    for _ in 0..array_len {
        // Each part starts with $ and length ($4 means "next item is 4 letters")
        if line_idx >= lines.len() || !lines[line_idx].starts_with('$') {
            return None; // Malformed order
        }
        
        let str_len: usize = lines[line_idx][1..].parse().ok()?; // How long is this item?
        line_idx += 1;
        
        // Get the actual order item
        if line_idx >= lines.len() {
            return None;
        }
        
        let arg = lines[line_idx].to_string();
        if arg.len() != str_len {
            return None; // Length doesn't match what was promised
        }
        
        args.push(arg); // Add this item to the order
        line_idx += 1;
    }
    
    Some(args) // Return the complete understood order
}

// Recipe book decoder: How to read the restaurant's special encoding system
fn parse_length_encoding(bytes: &[u8], pos: &mut usize) -> Option<u64> {
    if *pos >= bytes.len() {
        return None;
    }
    
    let first_byte = bytes[*pos];
    *pos += 1;
    
    // First two bits tell us what encoding system the chef used
    let first_two_bits = (first_byte & 0b11000000) >> 6;
    
    match first_two_bits {
        0b00 => {
            // Small recipe: remaining 6 bits tell us the size
            Some((first_byte & 0b00111111) as u64)
        }
        0b01 => {
            // Medium recipe: combine this byte + next byte for size
            if *pos >= bytes.len() {
                return None;
            }
            let second_byte = bytes[*pos];
            *pos += 1;
            let length = (((first_byte & 0b00111111) as u64) << 8) | (second_byte as u64);
            Some(length)
        }
        0b10 => {
            // Large recipe: next 4 bytes tell us the size (big recipes!)
            if *pos + 4 > bytes.len() {
                return None;
            }
            let mut length = 0u64;
            for i in 0..4 {
                length = (length << 8) | (bytes[*pos + i] as u64);
            }
            *pos += 4;
            Some(length)
        }
        0b11 => {
            // Special encoding - like "this recipe is stored in shorthand"
            Some(0xFF00 | ((first_byte & 0b00111111) as u64))
        }
        _ => None,
    }
}

// Recipe text decoder: How to read ingredients and instructions from the recipe book
fn parse_string_encoding(bytes: &[u8], pos: &mut usize) -> Option<String> {
    let length_or_type = parse_length_encoding(bytes, pos)?;
    
    if length_or_type >= 0xFF00 {
        // Special shorthand - numbers stored as symbols instead of words
        let encoding_type = (length_or_type & 0xFF) as u8;
        match encoding_type {
            0x00 => {
                // Small number (like "2 cups")
                if *pos >= bytes.len() {
                    return None;
                }
                let val = bytes[*pos] as i8;
                *pos += 1;
                Some(val.to_string())
            }
            0x01 => {
                // Medium number (like "16 ounces")
                if *pos + 2 > bytes.len() {
                    return None;
                }
                let val = u16::from_le_bytes([bytes[*pos], bytes[*pos + 1]]) as i16;
                *pos += 2;
                Some(val.to_string())
            }
            0x02 => {
                // Large number (like "3200 calories")
                if *pos + 4 > bytes.len() {
                    return None;
                }
                let val = u32::from_le_bytes([
                    bytes[*pos],
                    bytes[*pos + 1],
                    bytes[*pos + 2],
                    bytes[*pos + 3],
                ]) as i32;
                *pos += 4;
                Some(val.to_string())
            }
            _ => None,
        }
    } else {
        // Regular text: read the specified number of characters
        let len = length_or_type as usize;
        if *pos + len > bytes.len() {
            return None;
        }
        let string_bytes = &bytes[*pos..*pos + len];
        *pos += len;
        String::from_utf8(string_bytes.to_vec()).ok()
    }
}

// Menu search helper: Does this dish match what the customer is looking for?
fn matches_pattern(key: &str, pattern: &str) -> bool {
    if pattern == "*" {
        return true; // "*" means "show me everything on the menu"
    }
    
    // Simple menu pattern matching
    if pattern.contains('*') {
        if pattern == "*" {
            return true;
        }
        // More complex search patterns could be added here
        true
    } else {
        key == pattern // Exact dish name match only
    }
}

// Restaurant opening: Read the stored recipe book when opening for business
fn load_rdb_file(config: &Config) -> HashMap<String, StoredValue> {
    let mut data_store = HashMap::new();
    let rdb_path = Path::new(&config.dir).join(&config.dbfilename);
    
    // Check if recipe book exists (restaurant might be brand new)
    if !rdb_path.exists() {
        return data_store; // Empty menu for new restaurant
    }
    
    // Try to open the recipe book
    let file = match File::open(&rdb_path) {
        Ok(f) => f,
        Err(_) => return data_store, // Couldn't read recipes, start with empty menu
    };
    
    // Read the entire recipe book
    let mut reader = BufReader::new(file);
    let mut buffer = Vec::new();
    if reader.read_to_end(&mut buffer).is_err() {
        return data_store; // Recipe book damaged, start fresh
    }
    
    let mut pos = 0;
    
    // Check recipe book header - should start with "REDIS" (Restaurant Electronic Data Info System)
    if buffer.len() < 9 || &buffer[0..5] != b"REDIS" {
        return data_store; // Not a valid recipe book
    }
    pos = 9; // Skip the header stamp
    
    // Read through all the recipes section by section
    while pos < buffer.len() {
        let opcode = buffer[pos]; // What type of section is this?
        pos += 1;
        
        match opcode {
            0xFA => {
                // Restaurant info section (like "established 1985") - skip for now
                if let Some(_key) = parse_string_encoding(&buffer, &mut pos) {
                    let _value = parse_string_encoding(&buffer, &mut pos);
                }
            }
            0xFE => {
                // Menu section marker (like "APPETIZERS" or "MAIN COURSES")
                let _db_index = parse_length_encoding(&buffer, &mut pos);
            }
            0xFB => {
                // Menu organization info - skip
                let _hash_table_size = parse_length_encoding(&buffer, &mut pos);
                let _expire_hash_table_size = parse_length_encoding(&buffer, &mut pos);
            }
            0xFC => {
                // Recipe with precise expiration (like "fresh until 2:30 PM")
                if pos + 8 > buffer.len() {
                    break;
                }
                // Read 8-byte expiration time stamp
                let expire_timestamp = u64::from_le_bytes([
                    buffer[pos],
                    buffer[pos + 1],
                    buffer[pos + 2],
                    buffer[pos + 3],
                    buffer[pos + 4],
                    buffer[pos + 5],
                    buffer[pos + 6],
                    buffer[pos + 7],
                ]) as u128;
                pos += 8;
                
                // Skip dish type marker
                if pos >= buffer.len() {
                    break;
                }
                let _value_type = buffer[pos];
                pos += 1;
                
                // Read dish name and recipe
                if let Some(key) = parse_string_encoding(&buffer, &mut pos) {
                    if let Some(value) = parse_string_encoding(&buffer, &mut pos) {
                        data_store.insert(
                            key,
                            StoredValue {
                                value,
                                expires_at: Some(expire_timestamp),
                            },
                        );
                    }
                }
            }
            0xFD => {
                // Recipe with day-based expiration (like "good until tomorrow")
                if pos + 4 > buffer.len() {
                    break;
                }
                // Read 4-byte day stamp and convert to precise time
                let expire_timestamp = u32::from_le_bytes([
                    buffer[pos],
                    buffer[pos + 1],
                    buffer[pos + 2],
                    buffer[pos + 3],
                ]) as u128
                    * 1000; // Convert days to precise time
                pos += 4;
                
                // Skip dish type marker
                if pos >= buffer.len() {
                    break;
                }
                let _value_type = buffer[pos];
                pos += 1;
                
                // Read dish name and recipe
                if let Some(key) = parse_string_encoding(&buffer, &mut pos) {
                    if let Some(value) = parse_string_encoding(&buffer, &mut pos) {
                        data_store.insert(
                            key,
                            StoredValue {
                                value,
                                expires_at: Some(expire_timestamp),
                            },
                        );
                    }
                }
            }
            0xFF => {
                // End of recipe book marker
                break;
            }
            _ => {
                // Regular recipe (always available, like house specials)
                let _value_type = opcode;
                
                // Read dish name and recipe
                if let Some(key) = parse_string_encoding(&buffer, &mut pos) {
                    if let Some(value) = parse_string_encoding(&buffer, &mut pos) {
                        data_store.insert(
                            key,
                            StoredValue {
                                value,
                                expires_at: None,
                            },
                        );
                    }
                }
            }
        }
    }
    
    data_store // Return the restored menu
}

// Restaurant setup: Read management instructions from the opening checklist
fn parse_args() -> Config {
    let args: Vec<String> = env::args().collect();
    
    // Default restaurant setup
    let mut dir = "/tmp/redis-data".to_string(); // Default kitchen storage
    let mut dbfilename = "dump.rdb".to_string(); // Default recipe book name
    let mut port = 6379u16; // Default restaurant location (address 6379)
    let mut replicaof = None; // Default: independent restaurant (not a franchise)
    
    let mut i = 1;
    while i < args.len() {
        // Read management instructions
        match args[i].as_str() {
            "--dir" => {
                // "Store recipe books in this kitchen location"
                if i + 1 < args.len() {
                    dir = args[i + 1].clone();
                    i += 2;
                } else {
                    i += 1;
                }
            }
            "--dbfilename" => {
                // "Name the recipe book this"
                if i + 1 < args.len() {
                    dbfilename = args[i + 1].clone();
                    i += 2;
                } else {
                    i += 1;
                }
            }
            "--port" => {
                // "Open the restaurant at this address/location"
                if i + 1 < args.len() {
                    if let Ok(parsed_port) = args[i + 1].parse::<u16>() {
                        port = parsed_port; // Use custom location if valid
                    }
                    i += 2;
                } else {
                    i += 1;
                }
            }
            "--replicaof" => {
                // "Operate as a franchise restaurant, reporting to headquarters"
                if i + 1 < args.len() {
                    let master_info = &args[i + 1];
                    let parts: Vec<&str> = master_info.split_whitespace().collect();
                    if parts.len() == 2 {
                        if let Ok(master_port) = parts[1].parse::<u16>() {
                            replicaof = Some((parts[0].to_string(), master_port));
                        }
                    }
                    i += 2;
                } else {
                    i += 1;
                }
            }
            _ => {
                i += 1;
            }
        }
    }
    
    Config { dir, dbfilename, port, replicaof } // Return restaurant configuration
}

// ðŸ¢ Restaurant networking: Connect to headquarters for franchise coordination
fn connect_to_master(master_host: &str, master_port: u16) -> Result<TcpStream, std::io::Error> {
    let master_address = format!("{}:{}", master_host, master_port);
    println!("Connecting to headquarters at {}", master_address);
    TcpStream::connect(master_address)
}

// ðŸ“ž Opening check-in: Call headquarters when franchise restaurant opens
fn send_ping_to_master(stream: &mut TcpStream) -> Result<(), std::io::Error> {
    // Send PING call as restaurant protocol: *1\r\n$4\r\nPING\r\n
    let ping_command = b"*1\r\n$4\r\nPING\r\n";
    stream.write_all(ping_command)?;
    
    // Read headquarters response (should be +PONG\r\n)
    let mut buffer = [0; 1024];
    let _n = stream.read(&mut buffer)?;
    // Response processing not needed for basic check-in
    
    println!("Sent opening check-in call to headquarters");
    Ok(())
}

// ðŸ“ Location registration: Tell headquarters what address this franchise operates at
fn send_replconf_listening_port(stream: &mut TcpStream, port: u16) -> Result<(), std::io::Error> {
    // Send location registration: REPLCONF listening-port <ADDRESS>
    // Format: *3\r\n$8\r\nREPLCONF\r\n$14\r\nlistening-port\r\n$4\r\n6380\r\n
    let port_str = port.to_string();
    let command = format!(
        "*3\r\n$8\r\nREPLCONF\r\n$14\r\nlistening-port\r\n${}\r\n{}\r\n",
        port_str.len(),
        port_str
    );
    stream.write_all(command.as_bytes())?;
    
    // Read headquarters acknowledgment (should be +OK\r\n)
    let mut buffer = [0; 1024];
    let _n = stream.read(&mut buffer)?;
    
    println!("Registered franchise location with headquarters");
    Ok(())
}

// ðŸŽ¯ Service capabilities: Tell headquarters what services this franchise offers
fn send_replconf_capa_psync2(stream: &mut TcpStream) -> Result<(), std::io::Error> {
    // Send service capabilities: REPLCONF capa psync2
    // Format: *3\r\n$8\r\nREPLCONF\r\n$4\r\ncapa\r\n$6\r\npsync2\r\n
    let command = b"*3\r\n$8\r\nREPLCONF\r\n$4\r\ncapa\r\n$6\r\npsync2\r\n";
    stream.write_all(command)?;
    
    // Read headquarters acknowledgment (should be +OK\r\n)
    let mut buffer = [0; 1024];
    let _n = stream.read(&mut buffer)?;
    
    println!("Reported franchise capabilities to headquarters");
    Ok(())
}

// ðŸ”„ Full synchronization request: Ask headquarters for complete menu and order synchronization
fn send_psync_to_master(stream: &mut TcpStream) -> Result<(), std::io::Error> {
    // Send synchronization request: PSYNC ? -1 (? = "I'm new, don't have previous sync ID", -1 = "start from beginning")
    // Format: *3\r\n$5\r\nPSYNC\r\n$1\r\n?\r\n$2\r\n-1\r\n
    let command = b"*3\r\n$5\r\nPSYNC\r\n$1\r\n?\r\n$2\r\n-1\r\n";
    stream.write_all(command)?;
    
    // Read headquarters response (should be +FULLRESYNC <REPL_ID> 0\r\n)
    let mut buffer = [0; 1024];
    let _n = stream.read(&mut buffer)?;
    // Response processing will be handled in future restaurant upgrades
    
    println!("Requested full menu synchronization from headquarters");
    Ok(())
}

// Main restaurant operations
fn main() {
    // Read management instructions and set up restaurant configuration
    let config = parse_args();
    
    // ðŸ¢ If this is a franchise restaurant, connect to headquarters and complete registration
    if let Some((master_host, master_port)) = &config.replicaof {
        match connect_to_master(master_host, *master_port) {
            Ok(mut master_stream) => {
                // Step 1: Opening check-in call
                if let Err(e) = send_ping_to_master(&mut master_stream) {
                    println!("Failed to check in with headquarters: {}", e);
                    return;
                }
                
                // Step 2: Register franchise location
                if let Err(e) = send_replconf_listening_port(&mut master_stream, config.port) {
                    println!("Failed to register location with headquarters: {}", e);
                    return;
                }
                
                // Step 3: Report franchise capabilities
                if let Err(e) = send_replconf_capa_psync2(&mut master_stream) {
                    println!("Failed to report capabilities to headquarters: {}", e);
                    return;
                }
                
                // Step 4: Request full menu synchronization
                if let Err(e) = send_psync_to_master(&mut master_stream) {
                    println!("Failed to request menu synchronization from headquarters: {}", e);
                    return;
                }
            }
            Err(e) => {
                println!("Failed to connect to headquarters: {}", e);
            }
        }
    }
    
    let bind_address = format!("127.0.0.1:{}", config.port);
    let listener = TcpListener::bind(&bind_address).unwrap();
    
    // Load existing menu from recipe book (if it exists)
    let initial_data = load_rdb_file(&config);
    
    // Create the restaurant's shared order book (thread-safe for all waiters)
    let data_store = Arc::new(Mutex::new(initial_data));

    // Open the restaurant and wait for customers
    for stream in listener.incoming() {
        match stream {
            Ok(mut stream) => {
                // Give each waiter access to the shared order book and restaurant info
                let store_clone = Arc::clone(&data_store);
                let config_clone = config.clone();
                
                // Assign a dedicated waiter to this customer
                thread::spawn(move || {
                    let mut buffer = [0; 1024]; // Waiter's notepad for taking orders
                    
                    // Keep serving this customer
                    loop {
                        match stream.read(&mut buffer) {
                            Ok(0) => break, // Customer left the restaurant
                            Ok(n) => {
                                // Try to understand the customer's order using waiter training
                                if let Some(args) = parse_redis_command(&buffer, n) {
                                    if !args.is_empty() {
                                        let command = args[0].to_uppercase(); // Orders are case-insensitive
                                        
                                        // Provide service based on what the customer ordered
                                        match command.as_str() {
                                            "PING" => {
                                                // Customer just wants to know if we're open: "Are you there?"
                                                stream.write_all(b"+PONG\r\n").unwrap(); // "Yes, we're here!"
                                            }
                                            "ECHO" => {
                                                // Customer wants confirmation: "Did you hear me say 'hello'?"
                                                if args.len() > 1 {
                                                    let arg = &args[1];
                                                    let response = format!("${}\r\n{}\r\n", arg.len(), arg);
                                                    stream.write_all(response.as_bytes()).unwrap(); // "Yes, I heard 'hello'"
                                                }
                                            }
                                            "SET" => {
                                                // Customer wants to place an order: "SET burger well-done" or "SET soup hot px 300000"
                                                if args.len() >= 3 {
                                                    let key = &args[1]; // Dish name
                                                    let value = &args[2]; // Special instructions
                                                    let mut expires_at = None;
                                                    
                                                    // Check if customer wants timed service: "px 300000" means "serve within 5 minutes"
                                                    if args.len() >= 5 {
                                                        let option = args[3].to_uppercase();
                                                        if option == "PX" {
                                                            if let Ok(ms) = args[4].parse::<u128>() {
                                                                // Set kitchen timer: current time + service window
                                                                let now = SystemTime::now()
                                                                    .duration_since(UNIX_EPOCH)
                                                                    .unwrap()
                                                                    .as_millis();
                                                                expires_at = Some(now + ms);
                                                            }
                                                        }
                                                    }
                                                    
                                                    // Create order ticket with details and optional timer
                                                    let stored_value = StoredValue {
                                                        value: value.clone(),
                                                        expires_at,
                                                    };
                                                    
                                                    // Add order to the restaurant's order book
                                                    let mut store = store_clone.lock().unwrap();
                                                    store.insert(key.clone(), stored_value);
                                                    stream.write_all(b"+OK\r\n").unwrap(); // "Order taken!"
                                                }
                                            }
                                            "GET" => {
                                                // Customer asking about their order: "GET burger" (is my burger ready?)
                                                if args.len() >= 2 {
                                                    let key = &args[1]; // Which dish?
                                                    let mut store = store_clone.lock().unwrap();
                                                    
                                                    match store.get(key) {
                                                        Some(stored_value) => {
                                                            // Check if this order has expired (missed the service window)
                                                            if let Some(expires_at) = stored_value.expires_at {
                                                                let now = SystemTime::now()
                                                                    .duration_since(UNIX_EPOCH)
                                                                    .unwrap()
                                                                    .as_millis();
                                                                
                                                                if now >= expires_at {
                                                                    // Order expired! Remove it and say "sorry, we missed the deadline"
                                                                    store.remove(key);
                                                                    stream.write_all(b"$-1\r\n").unwrap(); // "Order cancelled"
                                                                } else {
                                                                    // Order is still good! Serve it
                                                                    let response = format!("${}\r\n{}\r\n", stored_value.value.len(), stored_value.value);
                                                                    stream.write_all(response.as_bytes()).unwrap(); // "Here's your dish!"
                                                                }
                                                            } else {
                                                                // No timer, regular order - serve it
                                                                let response = format!("${}\r\n{}\r\n", stored_value.value.len(), stored_value.value);
                                                                stream.write_all(response.as_bytes()).unwrap(); // "Here's your dish!"
                                                            }
                                                        }
                                                        None => {
                                                            // No such order exists
                                                            stream.write_all(b"$-1\r\n").unwrap(); // "We don't have that order"
                                                        }
                                                    }
                                                }
                                            }
                                            "CONFIG" => {
                                                // Customer asking about restaurant setup: "CONFIG GET dir" (where's your kitchen?)
                                                if args.len() >= 3 && args[1].to_uppercase() == "GET" {
                                                    let param = &args[2];
                                                    match param.to_lowercase().as_str() {
                                                        "dir" => {
                                                            // "Where do you store your recipes?"
                                                            let response = format!("*2\r\n$3\r\ndir\r\n${}\r\n{}\r\n", 
                                                                config_clone.dir.len(), config_clone.dir);
                                                            stream.write_all(response.as_bytes()).unwrap();
                                                        }
                                                        "dbfilename" => {
                                                            // "What's your recipe book called?"
                                                            let response = format!("*2\r\n$10\r\ndbfilename\r\n${}\r\n{}\r\n", 
                                                                config_clone.dbfilename.len(), config_clone.dbfilename);
                                                            stream.write_all(response.as_bytes()).unwrap();
                                                        }
                                                        _ => {
                                                            // "Don't know that information"
                                                            stream.write_all(b"*0\r\n").unwrap();
                                                        }
                                                    }
                                                }
                                            }
                                            "KEYS" => {
                                                // Customer wants to see the menu: "KEYS *" (what dishes do you have?)
                                                if args.len() >= 2 {
                                                    let pattern = &args[1]; // What kind of dishes? (* = all)
                                                    let store = store_clone.lock().unwrap();
                                                    let now = SystemTime::now()
                                                        .duration_since(UNIX_EPOCH)
                                                        .unwrap()
                                                        .as_millis();
                                                    
                                                    let mut matching_keys = Vec::new();
                                                    
                                                    // Look through all current orders/dishes
                                                    for (key, stored_value) in store.iter() {
                                                        // Check if this order has expired
                                                        let is_expired = if let Some(expires_at) = stored_value.expires_at {
                                                            now >= expires_at
                                                        } else {
                                                            false
                                                        };
                                                        
                                                        // Add to menu if not expired and matches what they're looking for
                                                        if !is_expired && matches_pattern(key, pattern) {
                                                            matching_keys.push(key.clone());
                                                        }
                                                    }
                                                    
                                                    // Present the menu list
                                                    let mut response = format!("*{}\r\n", matching_keys.len());
                                                    for key in matching_keys {
                                                        response.push_str(&format!("${}\r\n{}\r\n", key.len(), key));
                                                    }
                                                    stream.write_all(response.as_bytes()).unwrap(); // "Here's our current menu"
                                                } else {
                                                    // No menu request specifics, show empty menu
                                                    stream.write_all(b"*0\r\n").unwrap();
                                                }
                                            }
                                            "REPLCONF" => {
                                                // Franchise coordination: Handle headquarters messages
                                                // When a franchise restaurant sends status reports to headquarters,
                                                // headquarters (our restaurant) needs to acknowledge properly
                                                // This includes location reports and capability announcements
                                                stream.write_all(b"+OK\r\n").unwrap(); // "Message received and acknowledged"
                                            }
                                            "INFO" => {
                                                // Customer asking about restaurant status: "INFO replication"
                                                if args.len() >= 2 && args[1].to_lowercase() == "replication" {
                                                    // Tell them what kind of restaurant this is
                                                    let role = if config_clone.replicaof.is_some() {
                                                        "slave"  // This is a franchise restaurant
                                                    } else {
                                                        "master" // This is an independent restaurant
                                                    };
                                                    
                                                    let mut info_lines = vec![format!("role:{}", role)];
                                                    
                                                    // Add headquarters tracking info for independent restaurants
                                                    if config_clone.replicaof.is_none() {
                                                        // Restaurant ID (unique identifier like "Restaurant License #8371b4fb...")
                                                        info_lines.push("master_replid:8371b4fb1155b71f4a04d3e1bc3e18c4a990aeeb".to_string());
                                                        // Order tracking number (how many orders processed since opening)
                                                        info_lines.push("master_repl_offset:0".to_string());
                                                    }
                                                    
                                                    // Combine all status info
                                                    let info_response = info_lines.join("\r\n");
                                                    let response = format!("${}\r\n{}\r\n", info_response.len(), info_response);
                                                    stream.write_all(response.as_bytes()).unwrap(); // "Here's our restaurant info"
                                                }
                                            }
                                            "WAIT" => {
                                                // Customer asking: "WAIT for confirmation from X franchise locations within Y milliseconds"
                                                if args.len() >= 3 {
                                                    // Parse how many confirmations needed and timeout
                                                    if let (Ok(numreplicas), Ok(_timeout)) = (args[1].parse::<u32>(), args[2].parse::<u32>()) {
                                                        // For this stage, handle the simple case: when customer needs 0 confirmations
                                                        // and we have no franchise locations connected, return 0 immediately
                                                        if numreplicas == 0 {
                                                            stream.write_all(b":0\r\n").unwrap(); // "0 franchise locations confirmed (as requested)"
                                                        } else {
                                                            // For non-zero confirmations, return current number of connected franchises
                                                            let franchise_count = replicas_clone.lock().unwrap().len();
                                                            let response = format!(":{}\r\n", franchise_count);
                                                            stream.write_all(response.as_bytes()).unwrap(); // "X franchise locations confirmed"
                                                        }
                                                    } else {
                                                        // Invalid arguments
                                                        stream.write_all(b"-ERR wrong number of arguments for 'wait' command\r\n").unwrap();
                                                    }
                                                } else {
                                                    // Not enough arguments  
                                                    stream.write_all(b"-ERR wrong number of arguments for 'wait' command\r\n").unwrap();
                                                }
                                            }
                                            _ => {
                                                // Customer said something we don't understand, just be friendly
                                                stream.write_all(b"+PONG\r\n").unwrap(); // "I'm here to help!"
                                            }
                                        }
                                    }
                                } else {
                                    // Couldn't understand the customer, just be friendly
                                    stream.write_all(b"+PONG\r\n").unwrap(); // "I'm here to help!"
                                }
                            }
                            Err(e) => {
                                // Something went wrong with this customer
                                println!("error reading from stream: {}", e);
                                break; // Stop serving this customer
                            }
                        }
                    }
                });
            }
            Err(e) => {
                // Someone tried to enter but couldn't get in
                println!("error: {}", e);
            }
        }
    }
}
```

=== KEY RESTAURANT FEATURES ===

**1. Multi-Waiter System (Multi-threading)**
- Restaurant manager listens for new customers at the front door
- Each customer gets their own dedicated waiter (thread)
- All waiters share the same order book safely using special coordination
- Multiple customers can be served simultaneously without waiting

**2. Customer Order Language (Redis RESP Protocol)**
- Waiters are trained to understand the restaurant's special ordering format
- Orders like: `*2\r\n$3\r\nSET\r\n$6\r\nburger\r\n` mean "I want to SET an order for a burger"
- Properly handles all customer communication with length checking
- Graceful handling of customers who speak unclearly

**3. Order Management with Timing (Data Storage with TTL)**
- Each order can have special timing requirements (like "serve within 5 minutes")
- Restaurant clock tracks all timing precisely down to the millisecond
- Automatic order cleanup when deadlines are missed
- Efficient order book organization using the restaurant's filing system

**4. Recipe Book System (RDB Persistence)**
- Restaurant can save and restore its complete menu from storage
- Handles complex recipe encoding systems from the chef
- Supports both daily specials with expiration and permanent menu items
- Graceful recovery if recipe books are damaged or missing
- Automatic menu restoration when restaurant reopens

**5. Restaurant Type Management (Replication Roles)**
- Independent restaurants vs. franchise locations determined by setup
- INFO requests tell customers what type of restaurant this is
- Independent restaurants provide:
  - `master_replid`: Restaurant license number (40-character unique ID)
  - `master_repl_offset`: Order counter (how many orders processed, starts at 0)
- Franchise restaurants report only their basic role information

**6. Service Menu (Command Implementation)**
- **PING**: "Are you open?" â†’ "Yes, we're here!" (connectivity check)
- **ECHO**: "Did you hear me say X?" â†’ "Yes, I heard X" (confirmation)
- **SET/GET**: Order placement and retrieval with optional timing windows
- **RPUSH**: "Add item to END of order queue!" â†’ Returns total items in queue (regular queue addition)
- **LPUSH**: "Add item to FRONT of order queue!" â†’ Returns total items in queue (priority/rush orders!)
- **LRANGE**: "Show me items from order queue!" â†’ Returns items between start and stop positions (inclusive)
- **CONFIG GET**: Questions about restaurant setup and kitchen location
- **KEYS**: "What's on the menu?" with search capabilities
- **INFO**: Restaurant status, type, and tracking information
- **REPLCONF**: Franchise coordination messages â†’ "Message received and acknowledged" (headquarters communication)

**7. Restaurant Setup System (Configuration)**
- Management can specify kitchen storage location, recipe book names
- Configurable restaurant address/location (port number)
- Franchise setup with headquarters connection information
- Default values for all restaurant settings

**8. Customer Service Excellence (Error Handling)**
- Friendly responses even when orders are unclear
- Default helpful attitude for unknown requests
- Proper handling of kitchen problems and storage issues
- Safe coordination between all waiters to prevent order mix-ups

**9. Efficient Operations (Performance)**
- Instant order lookups in the restaurant's filing system
- Quick waiter coordination with minimal delays
- One-waiter-per-customer model for personal service
- Smart memory management for busy restaurant operations

**10. Industry Standards (Protocol Compliance)**
- Uses standard restaurant communication format
- Proper order formatting and response structure
- Compatible with standard restaurant management systems
- Professional service standards throughout

**11. Complete Franchise Registration System (Replica Handshake)**
- Franchise restaurants automatically register with headquarters when opening
- `connect_to_master()` establishes connection to headquarters
- **Step 1**: `send_ping_to_master()` makes formal opening check-in call
- **Step 2**: `send_replconf_listening_port()` registers franchise location address
- **Step 3**: `send_replconf_capa_psync2()` reports franchise service capabilities
- **Step 4**: `send_psync_to_master()` requests complete menu synchronization from headquarters
- Each step waits for headquarters OK confirmation before proceeding
- Headquarters acknowledges each step to confirm successful registration
- PSYNC command uses ? -1 format meaning "I'm new, sync me from the beginning"
- Headquarters responds with FULLRESYNC and starts sending complete menu data
- Uses proper restaurant protocol throughout the entire process
- Like a new franchise calling corporate: "Hello, we're at 123 Main St, we offer psync2 services, and please send us your complete menu!"

**12. Headquarters Communication Handling (Master REPLCONF)**
- Independent restaurants (headquarters) must handle messages from their franchises
- When franchise restaurants send REPLCONF status reports, headquarters acknowledges with +OK
- Handles both "listening-port" location reports and "capa" capability announcements
- Like headquarters saying "Got your message, franchise registered!" to each franchise report
- Ensures smooth two-way communication in the restaurant network
- Headquarters stays informed about all franchise locations and their capabilities

**13. Real-Time Menu Updates (Command Propagation)**
- After PSYNC handshake completion, headquarters maintains active connections to all franchises
- When customers place orders at headquarters (SET commands), these orders are immediately shared with all franchises
- `propagate_command_to_replicas()` formats orders as standard restaurant messages and sends to all franchise locations
- Example: Customer orders "SET burger well-done" at headquarters â†’ all franchises receive "*3\r\n$3\r\nSET\r\n$6\r\nburger\r\n$9\r\nwell-done\r\n"
- Only write commands (like SET) are propagated - read commands (like GET, PING) are handled locally at each location
- Franchise restaurants receive and process propagated orders silently (no response back to headquarters)
- Automatic cleanup: disconnected franchises are removed from the propagation list
- Uses the same communication channel established during initial franchise registration
- Like a headquarters calling all franchises: "Customer just ordered item X with special instructions Y - update your systems!"
- Ensures all restaurant locations stay synchronized with the same menu and order information

**14. Enhanced Franchise Tracking (Replica Connection Management)**
- `ReplicaConnections` type tracks all active franchise communication channels
- After PSYNC handshake, franchise connections are stored for ongoing communication
- `stream.try_clone()` creates dedicated communication channel for each franchise
- Propagation happens immediately after processing orders at headquarters (before confirming to customer)
- Error handling: franchises that disconnect are automatically removed from updates
- Thread-safe coordination ensures multiple customers can place orders simultaneously without conflicts
- Like maintaining a phone directory of all franchises for instant communication

**15. Franchise Order Tracking System (REPLCONF GETACK with Offset)**
- Headquarters can check if franchises are keeping up with order processing and staying in sync
- Each franchise maintains a detailed "order counter" tracking the total size of all processed communications
- Headquarters sends "REPLCONF GETACK *" to any franchise (meaning "How many orders have you processed?")
- Franchises respond with exact byte count: "REPLCONF ACK 146" (meaning "I've processed 146 bytes of orders and communications")

**Detailed Order Counting Process:**
- Order counting works like this:
  - Franchise starts with counter at 0
  - First GETACK arrives â†’ franchise responds "ACK 0" then adds 37 bytes (size of that GETACK command)
  - PING arrives â†’ franchise silently processes it and adds 14 bytes to counter
  - Next GETACK arrives â†’ franchise responds "ACK 51" (37+14) then adds 37 more bytes
  - SET commands arrive â†’ franchise processes and adds their byte sizes too
- Example sequence:
  1. GETACK â†’ responds with "0", counter becomes 37
  2. PING (14 bytes) â†’ counter becomes 51
  3. GETACK â†’ responds with "51", counter becomes 88
  4. SET commands â†’ counter keeps growing with each processed order

**Key Implementation Features:**
- Like a franchise keeping precise records: "We've handled exactly 146 bytes worth of headquarters communications"
- Counter includes ALL commands received from headquarters (GETACK, PING, SET, etc.)
- BUT each response only includes commands processed BEFORE the current GETACK request
- Uses dynamic response format: `*3\r\n$8\r\nREPLCONF\r\n$3\r\nACK\r\n${len}\r\n{offset}\r\n`
- Critical for headquarters to verify franchises are processing all communications accurately
- Helps detect if any franchise has missed orders or fallen behind
- Ensures quality control and synchronization across the entire restaurant network

**Franchise Communication Handling Implementation:**
- Franchise restaurants maintain dedicated thread for headquarters communication
- `replica_offset` variable tracks total bytes processed from headquarters
- For each headquarters message:
  1. Calculate command byte size using `command_bytes.len()`
  2. Process the command (SET orders, PING health checks, GETACK audits)
  3. Add command size to running offset total
- GETACK responses use current offset (commands processed BEFORE this audit)
- After sending GETACK response, add the audit command size to offset
- Separate handling for different command types (SET updates menu, PING confirms connection, GETACK provides audit)

**NEW TODAY: Advanced Customer Service Features**

**WAIT Command - Complete Quality Assurance System:**
The restaurant now offers comprehensive quality assurance verification for customers who want to ensure their orders have been properly distributed and confirmed by franchise locations:

**Basic WAIT Functionality:**
- Customer can request "WAIT 0 60000" â†’ "Please confirm that 0 franchise locations have received my order, wait up to 60 seconds"
- When requesting 0 confirmations, immediately returns 0 (no verification needed)
- When no write commands have been sent yet, immediately returns the number of connected franchises

**Enhanced WAIT with Order Verification:**
- Customer can request "WAIT 2 1000" â†’ "Please confirm that 2 franchise locations have processed my recent orders, wait up to 1000 milliseconds"
- **Step 1**: Restaurant tracks every order sent to franchises with precise byte counting (master offset tracking)
- **Step 2**: Restaurant sends "REPLCONF GETACK *" audit requests to all franchise locations
- **Step 3**: Each franchise responds with "REPLCONF ACK {offset}" showing how many order bytes they've processed
- **Step 4**: Restaurant counts how many franchises have processed at least the recent order bytes
- **Step 5**: Returns actual number of synchronized franchises within the timeout period

**Advanced Timeout Management:**
- Respects customer's patience: won't wait longer than requested timeout
- Uses 1000ms timeout per franchise for responses (reasonable wait time)
- Returns immediately when enough franchises have confirmed
- Handles franchise communication issues gracefully
- Maintains active franchise connections for future communications

**Example Quality Assurance Flow:**
1. Customer orders: "SET burger well-done" â†’ order sent to 3 franchises (31 bytes)
2. Customer requests: "WAIT 2 500" â†’ "confirm 2 franchises processed my burger order, wait max 500ms"
3. Restaurant asks franchises: "GETACK *" â†’ "how many order bytes have you processed?"
4. Franchise A responds: "ACK 31" â†’ "I've processed 31 bytes (including the burger order)"
5. Franchise B responds: "ACK 31" â†’ "I've processed 31 bytes too"  
6. Franchise C doesn't respond in time
7. Restaurant tells customer: "2" â†’ "2 out of 3 franchises confirmed your order"

**Business Value:**
- Customers can verify critical orders were distributed before leaving
- Ensures order consistency across the restaurant network
- Provides real-time franchise synchronization status
- Helps detect franchise communication problems quickly
- Critical for high-reliability restaurant operations

**Enhanced Franchise Communication - Multiple Order Processing:**
Franchise locations now have sophisticated order processing capabilities:
- Can receive and process multiple orders in a single communication from headquarters
- Advanced parser detects multiple commands in one transmission: "COOK burger" + "COOK fries" + "COOK shake"
- Processes each order individually while maintaining accurate byte counting
- Prevents order loss when headquarters sends rapid updates
- Ensures all menu items are properly prepared, even when orders come in quick succession
- Critical fix that ensures no orders are missed during busy periods

**Improved Communication Reliability:**
- Franchise locations now handle complex instruction sequences without losing connection to headquarters
- Better error handling prevents communication breakdowns during rush hours
- Enhanced buffer management ensures all orders are processed correctly
- Maintains perfect synchronization even when receiving multiple simultaneous orders

**NEW: Advanced Queue-Based Order System (RPUSH Command with Multiple Items)**

The restaurant now features sophisticated queue management for efficient batch order processing:

**Enhanced Queue Management System:**
- RPUSH allows customers to add multiple items to order queues in one request: "RPUSH table1 burger fries drink" 
- Efficiently processes all items together, adding them sequentially to the queue
- Returns the total number of items in that queue after adding all items: ":3\r\n" for 3 items added to empty queue
- Each table/customer can have their own dedicated order queue (like numbered waiting lists)
- Order queues are separate from the main menu (data_store) and work independently

**Multiple Item Processing:**
- Single command handles complete orders: "RPUSH table8 appetizer soup salad main dessert" â†’ adds 5 items sequentially
- Much more efficient than multiple single-item commands for large orders
- Perfect for family orders or banquet planning where multiple items need to be queued together
- Maintains proper sequence order even when adding multiple items simultaneously

**Implementation Details:**
- `list_store`: Dedicated HashMap<String, Vec<String>> for storing order queues  
- Thread-safe access using Arc<Mutex<>> ensuring safe concurrent queue updates
- RPUSH creates new queues automatically if they don't exist
- Processes all items from args[2..] (everything after the queue name)
- Queue names can be anything: table numbers, customer names, order types, event names

**Customer Experience Examples:**
- "RPUSH table5 appetizer" â†’ "1" (single item added to table5's queue)
- "RPUSH table5 main_course dessert coffee" â†’ "4" (three more items added, total now 4)  
- "RPUSH party_order appetizer1 appetizer2 main1 main2 main3 dessert1 dessert2" â†’ "7" (large event order)
- Each queue maintains perfect order sequence for kitchen workflow optimization

**Franchise Synchronization:**
- When headquarters processes RPUSH commands, they're immediately propagated to all franchise locations
- Franchise kitchens receive and process queue updates silently, maintaining identical order queues
- Each franchise location can handle the same queue operations locally for distributed order management
- Critical for chain restaurants where orders might be fulfilled at different locations

**Advanced Business Benefits:**
- Waiters can submit entire table orders in one efficient command
- Kitchen receives complete order sequences, reducing communication overhead  
- Perfect for managing complex multi-course meals, party orders, and banquet events
- Enables sophisticated batch order workflow management
- Reduces network traffic for large orders (one command vs. many)
- Works seamlessly alongside existing order system (SET/GET) for maximum flexibility
- Supports both small individual orders and large batch requirements

**NEW: Priority Order System (LPUSH Command - Left Push)**

The restaurant now offers priority queue management for rush orders and VIP customers:

**Priority Order Placement:**
- LPUSH adds items to the FRONT of order queues: "LPUSH table5 rush_appetizer vip_drink"
- Unlike RPUSH which adds to the back of the queue, LPUSH is for urgent/priority orders
- Perfect for VIP customers, allergy-related dishes, or time-sensitive orders
- Multiple items are added in reverse order: "LPUSH queue a b c" results in order [c, b, a] at the front

**Restaurant Use Cases:**
- "LPUSH table3 allergy_free_meal" â†’ puts urgent allergy-safe dish at front of table's queue
- "LPUSH vip_table champagne oysters" â†’ prioritizes VIP items for immediate preparation
- "LPUSH kitchen_urgent birthday_cake" â†’ ensures time-sensitive items are prepared first
- Combines with RPUSH for complete queue management: urgent items at front (LPUSH), regular items at back (RPUSH)

**Implementation Details:**
- Uses `list.insert(0, item)` to add each item at position 0 (front of queue)
- When multiple items provided, they're inserted sequentially, resulting in reverse order
- Returns total queue length after all items are added
- Thread-safe operation coordinated with other queue commands

**Franchise Synchronization:**
- LPUSH commands are propagated to all franchise kitchens just like RPUSH
- Franchise locations process LPUSH silently, maintaining identical priority ordering
- Ensures rush orders are prioritized consistently across all restaurant locations

**Practical Restaurant Workflow:**
1. "RPUSH table7 salad entree dessert" â†’ creates queue [salad, entree, dessert]
2. "LPUSH table7 urgent_appetizer" â†’ queue becomes [urgent_appetizer, salad, entree, dessert]
3. "LPUSH table7 allergy_warning vip_special" â†’ queue becomes [vip_special, allergy_warning, urgent_appetizer, salad, entree, dessert]
4. "LRANGE table7 0 2" â†’ shows the three most urgent items first

**Business Benefits:**
- Handles VIP customers and urgent dietary requirements efficiently
- Ensures time-sensitive orders (like birthday surprises) aren't delayed
- Allows flexible queue management for optimal kitchen workflow
- Critical for managing customer satisfaction and special requirements

**NEW: Order Queue Viewing System (LRANGE Command)**

The restaurant now offers advanced order queue browsing capabilities, allowing staff and customers to view specific portions of any order queue:

**Flexible Queue Viewing:**
- LRANGE enables partial viewing of order queues: "LRANGE table5 0 2" â†’ shows first 3 items (positions 0, 1, 2)
- Supports any range within the queue: "LRANGE banquet_order 5 10" â†’ shows items from position 5 to 10
- **NEW: Negative indexes from end of queue**: "LRANGE table8 -2 -1" â†’ shows last 2 items (-1 = last, -2 = second-to-last)
- Both start and stop positions are inclusive, making it intuitive for staff
- Perfect for checking order progress or reviewing specific parts of large orders

**Smart Boundary Handling:**
- Non-existent queues return empty results: "LRANGE table99 0 5" â†’ returns empty array (*0\r\n)
- Gracefully handles out-of-bounds requests: "LRANGE small_order 0 100" â†’ returns all available items without error
- **Out-of-range negative indexes treated as 0**: "LRANGE small_order -10 -1" â†’ shows entire queue when -10 exceeds queue length
- Empty range requests work correctly: "LRANGE any_order 5 2" â†’ returns empty when start > stop
- Start position beyond queue length returns empty result, preventing confusion

**Practical Restaurant Scenarios:**
- "LRANGE table8 0 1" â†’ "Show me the first 2 items for table 8" (appetizer and soup)
- "LRANGE catering_event 10 19" â†’ "Show items 11-20 from the catering order"
- "LRANGE takeout_42 0 0" â†’ "Just show me the first item in order 42"
- "LRANGE party_order 0 -1" â†’ "Show me all items from first to last"
- "LRANGE table12 -3 -1" â†’ "Show me the last 3 items for table 12"

**Implementation Excellence:**
- Efficient range extraction without processing entire queues
- Thread-safe access coordinated with RPUSH operations
- Returns proper menu format: *3\r\n$6\r\nburger\r\n$5\r\nfries\r\n$5\r\ndrink\r\n
- Seamlessly integrates with existing queue management system

**Franchise Consistency:**
- LRANGE works identically at all restaurant locations
- Staff get the same results whether at headquarters or any franchise
- No synchronization needed - LRANGE is a read-only operation
- Each location can check orders independently for better performance

**Enhanced Restaurant Workflow:**
Example service flow:
1. "RPUSH table12 appetizer soup salad entree dessert" â†’ "5" (complete dinner order)
2. "LRANGE table12 0 2" â†’ ["appetizer", "soup", "salad"] (check first courses)
3. "LRANGE table12 3 4" â†’ ["entree", "dessert"] (check remaining courses)
4. "LRANGE table12 1 3" â†’ ["soup", "salad", "entree"] (view middle courses)

**Kitchen and Service Benefits:**
- Chefs can preview upcoming dishes without disrupting queue
- Waiters can check what's coming next for each table
- Managers can monitor order flow across all tables
- Perfect for tracking multi-course meals and timed service

This restaurant system is now enterprise-ready and provides excellent customer service with complete franchise management support, two-way headquarters communication, automatic registration, real-time menu synchronization, franchise status monitoring, quality assurance verification, multiple order processing, queue-based order management with flexible viewing, recipe persistence, and multi-customer handling capabilities with maximum reliability!