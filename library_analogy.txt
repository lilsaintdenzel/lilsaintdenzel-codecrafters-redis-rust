Redis Server Code Explanation - Digital Library Analogy

This Redis server code works like a smart digital library system:

**The Library Building (Server)**
- Opens at "127.0.0.1:6379" by default (like a library address)
- **NEW**: Can now open branch locations with `--port` flag for multiple library branches!
- **NEW**: Can operate as a replica library with `--replicaof` flag, connecting to a master library!
- Welcomes visitors (clients) through the front door

**When Visitors Arrive**
- Each visitor gets their own librarian (thread) 
- The librarian stays with that visitor throughout their entire visit
- Multiple visitors can be helped simultaneously by different librarians

**How Librarians Understand Requests (Redis Protocol Parser)**
The librarians are specially trained to understand the library's cataloging system! They can decode structured requests:
- Visitors don't just say "PING" - they use the library's format: `*2\r\n$4\r\nECHO\r\n$3\r\nhey\r\n`
- The librarian (parser) interprets this:
  - `*2` = "This request has 2 parts"
  - `$4\r\nECHO` = "First part is 4 letters: ECHO"
  - `$3\r\nhey` = "Second part is 3 letters: hey"
- So the librarian understands: "Visitor wants ECHO service with parameter 'hey'"

**What Each Librarian Does Now**
1. Listens to what the visitor needs (reads data)
2. **NEW**: Decodes the library's cataloging format (Redis protocol)
3. **NEW**: Processes different types of requests:
   - If they say "PING" ‚Üí responds "PONG" (simple confirmation: `+PONG\r\n`)
   - If they say "ECHO [something]" ‚Üí repeats back exactly what they said (formatted response: `$3\r\nhey\r\n`)
   - **If they say "SET [title] [content]" ‚Üí stores it in the library's catalog and confirms "OK"**
   - **If they say "SET [title] [content] px [time]" ‚Üí stores it as a temporary exhibit that expires after the specified time!**
   - **If they say "GET [title]" ‚Üí looks up the title in the catalog and provides the content (or "not found" if expired)**
   - **If they say "RPUSH [reading-list] [book]" ‚Üí adds book to the specified reading list and returns total books in that list**
   - **If they say "CONFIG GET [setting]" ‚Üí provides information about the library's configuration (like where archive files are stored)**
   - **If they say "KEYS [pattern]" ‚Üí shows all currently available titles in the catalog (excluding expired exhibits)**
   - **If they say "INFO replication" ‚Üí provides information about the library's role and replication status (reports role:master with master_replid and master_repl_offset for main library, role:slave for replica library)**
   - **If they say "WAIT [minimum_confirmations] [timeout]" ‚Üí checks how many branch libraries have confirmed they received recent updates and waits up to the timeout period (for this stage, immediately returns 0 when requesting 0 confirmations)**
   - If they say something else ‚Üí defaults to "PONG"
4. Continues helping until the visitor leaves
5. If something goes wrong, the librarian stops serving that visitor

**Key Benefits**
- Multiple visitors can be served simultaneously (concurrent connections)
- One slow visitor doesn't delay others
- Each interaction is independent
- **NEW**: Librarians can understand different types of requests!
- **NEW**: Responses are properly formatted in the library's cataloging system
- **NEW**: The library has a shared catalog that all librarians can access safely
- **NEW**: Visitors can store and retrieve information (SET/GET operations)
- **NEW**: The library can handle temporary exhibits that automatically expire!
- **NEW**: The library can remember its collection even after closing by reading from archive files when it reopens (RDB persistence)
- **NEW**: Visitors can browse what's currently available using the KEYS command
- **NEW**: The library can open multiple branch locations on different addresses (port configuration for distributed libraries)
- **NEW**: The library can operate as a replica, connecting to a master library for coordination (--replicaof flag)
- **NEW**: Replica libraries automatically perform an opening handshake with their master library by sending a PING greeting
- **NEW**: Visitors can ask about the library's role and status using the INFO command (reports role:master with replication tracking for main library, role:slave for replica)
- **NEWEST**: Advanced Branch Processing Tracking System - replica libraries now maintain detailed logs of every instruction received from the main library, tracking the exact number of bytes processed and responding to audit requests with precise progress reports!

**Branch Processing Tracking System (Offset Tracking)**
When a library operates as a branch (replica), it implements sophisticated tracking:
- **Precise Byte Counting**: Every single instruction from the main library is measured and logged
- **Audit Response System**: When the main library asks "How much have you processed?" (REPLCONF GETACK), the branch responds with exact byte counts
- **Sequential Processing**: Instructions are processed in order, with byte counts tracked before, during, and after each operation
- **Training Material Handling**: Branch libraries properly separate initial training materials (RDB files) from ongoing operational instructions
- **Real-time Synchronization**: Maintains perfect synchronization by tracking all communication, not just catalog updates

The library is now much more sophisticated - it can handle different services, manage temporary collections with expiration times, support multiple branches, respond appropriately to all visitor needs, AND maintain precise operational tracking for seamless coordination with the main library!

==== CODE WITH LIBRARY COMMENTS ====

```rust
// Library imports - tools we need
use std::collections::HashMap;  // The library's catalog system
use std::env;                   // For reading administrative instructions (command line args)
use std::fs::File;              // For reading archive files
use std::io::{BufReader, Read, Write}; // For communicating with visitors and reading files
use std::net::{TcpListener, TcpStream}; // The library building and connections to master library
use std::path::Path;            // For working with file paths
use std::sync::{Arc, Mutex};    // Safe way to share the catalog between librarians
use std::thread;                // Librarians
use std::time::{SystemTime, UNIX_EPOCH};  // Library's clock for exhibition timers

// üìö Special catalog entry with expiration timer
#[derive(Clone)]
struct StoredValue {
    value: String,              // The content/book
    expires_at: Option<u128>,   // When this exhibit expires (library's clock time)
}

// üèõÔ∏è Library configuration - where to keep archives and which address to use
#[derive(Clone)]
struct Config {
    dir: String,                // Directory where archive files are stored
    dbfilename: String,         // Name of the archive file
    port: u16,                  // Which address to open the library at
    replicaof: Option<(String, u16)>, // If this is a replica, connect to this master (host, port)
}

// üß† Special librarian training: How to understand visitor requests
fn parse_redis_command(buffer: &[u8], n: usize) -> Option<Vec<String>> {
    let data = String::from_utf8_lossy(&buffer[..n]);
    let lines: Vec<&str> = data.split("\r\n").collect();
    
    // Check if it's a proper request format (*number means "request has X parts")
    if lines.is_empty() || !lines[0].starts_with('*') {
        return None;  // Can't understand this request
    }
    
    let array_len: usize = lines[0][1..].parse().ok()?;  // How many parts?
    let mut args = Vec::new();  // Collect request parts here
    let mut line_idx = 1;
    
    // Parse each part of the request
    for _ in 0..array_len {
        // Each part starts with $ and length ($4 means "next part is 4 letters")
        if line_idx >= lines.len() || !lines[line_idx].starts_with('$') {
            return None;  // Malformed request
        }
        
        let str_len: usize = lines[line_idx][1..].parse().ok()?;
        line_idx += 1;
        
        // Get the actual word
        if line_idx >= lines.len() {
            return None;
        }
        
        let arg = lines[line_idx].to_string();
        if arg.len() != str_len {
            return None;  // Length doesn't match
        }
        
        args.push(arg);  // Add this word to the request
        line_idx += 1;
    }
    
    Some(args)  // Return the understood request
}

// üîç Special archive decoder: How to read library archive files (RDB format)
fn parse_length_encoding(bytes: &[u8], pos: &mut usize) -> Option<u64> {
    // This is like reading the library's special archival system where each entry
    // starts with a code that tells you how long the next piece of information is
    if *pos >= bytes.len() {
        return None;
    }
    
    let first_byte = bytes[*pos];
    *pos += 1;
    
    let first_two_bits = (first_byte & 0b11000000) >> 6;
    
    match first_two_bits {
        0b00 => {
            // Small number: the remaining 6 bits tell us the length
            Some((first_byte & 0b00111111) as u64)
        }
        0b01 => {
            // Medium number: combine this byte + next byte for length
            if *pos >= bytes.len() { return None; }
            let second_byte = bytes[*pos];
            *pos += 1;
            let length = (((first_byte & 0b00111111) as u64) << 8) | (second_byte as u64);
            Some(length)
        }
        0b10 => {
            // Large number: next 4 bytes tell us the length
            if *pos + 4 > bytes.len() { return None; }
            let mut length = 0u64;
            for i in 0..4 {
                length = (length << 8) | (bytes[*pos + i] as u64);
            }
            *pos += 4;
            Some(length)
        }
        0b11 => {
            // Special encoding marker - like "this entry is stored in a special way"
            Some(0xFF00 | ((first_byte & 0b00111111) as u64))
        }
        _ => None,
    }
}

// üìñ Text decoder: How to read content from the archive files
fn parse_string_encoding(bytes: &[u8], pos: &mut usize) -> Option<String> {
    let length_or_type = parse_length_encoding(bytes, pos)?;
    
    if length_or_type >= 0xFF00 {
        // Special encoding - numbers stored as binary instead of text
        let encoding_type = (length_or_type & 0xFF) as u8;
        match encoding_type {
            0x00 => {
                // 8-bit number
                if *pos >= bytes.len() { return None; }
                let val = bytes[*pos] as i8;
                *pos += 1;
                Some(val.to_string())
            }
            0x01 => {
                // 16-bit number (little-endian)
                if *pos + 2 > bytes.len() { return None; }
                let val = u16::from_le_bytes([bytes[*pos], bytes[*pos + 1]]) as i16;
                *pos += 2;
                Some(val.to_string())
            }
            0x02 => {
                // 32-bit number (little-endian)
                if *pos + 4 > bytes.len() { return None; }
                let val = u32::from_le_bytes([
                    bytes[*pos], bytes[*pos + 1], bytes[*pos + 2], bytes[*pos + 3],
                ]) as i32;
                *pos += 4;
                Some(val.to_string())
            }
            _ => None,
        }
    } else {
        // Regular text: read the specified number of bytes
        let len = length_or_type as usize;
        if *pos + len > bytes.len() { return None; }
        let string_bytes = &bytes[*pos..*pos + len];
        *pos += len;
        String::from_utf8(string_bytes.to_vec()).ok()
    }
}

// üîç Pattern matching helper: Does this title match what the visitor searched for?
fn matches_pattern(key: &str, pattern: &str) -> bool {
    if pattern == "*" {
        return true; // "*" means "show me everything"
    }
    
    // Simple pattern matching
    if pattern.contains('*') {
        if pattern == "*" {
            return true;
        }
        // More complex patterns could be added here
        true
    } else {
        key == pattern // Exact match only
    }
}

// üóÉÔ∏è Library opening: Read the archive file when opening
fn load_rdb_file(config: &Config) -> HashMap<String, StoredValue> {
    let mut data_store = HashMap::new();
    let rdb_path = Path::new(&config.dir).join(&config.dbfilename);
    
    // Check if archive file exists (library might be brand new)
    if !rdb_path.exists() {
        return data_store; // Empty catalog for new library
    }
    
    // Try to open the archive file
    let file = match File::open(&rdb_path) {
        Ok(f) => f,
        Err(_) => return data_store, // Couldn't read file, start fresh
    };
    
    // Read the entire file
    let mut reader = BufReader::new(file);
    let mut buffer = Vec::new();
    if reader.read_to_end(&mut buffer).is_err() {
        return data_store; // File corrupted, start fresh
    }
    
    let mut pos = 0;
    
    // Check file header - should start with "REDIS0011"
    if buffer.len() < 9 || &buffer[0..5] != b"REDIS" {
        return data_store; // Not a valid archive file
    }
    pos = 9; // Skip header
    
    // Parse the archive file section by section
    while pos < buffer.len() {
        let opcode = buffer[pos]; // What type of section is this?
        pos += 1;
        
        match opcode {
            0xFA => {
                // Metadata section (library info) - skip for now
                if let Some(_key) = parse_string_encoding(&buffer, &mut pos) {
                    let _value = parse_string_encoding(&buffer, &mut pos);
                }
            }
            0xFE => {
                // Database section marker
                let _db_index = parse_length_encoding(&buffer, &mut pos);
            }
            0xFB => {
                // Hash table size info - skip
                let _hash_table_size = parse_length_encoding(&buffer, &mut pos);
                let _expire_hash_table_size = parse_length_encoding(&buffer, &mut pos);
            }
            0xFC => {
                // Entry with millisecond expiration
                if pos + 8 > buffer.len() { break; }
                let expire_timestamp = u64::from_le_bytes([
                    buffer[pos], buffer[pos + 1], buffer[pos + 2], buffer[pos + 3],
                    buffer[pos + 4], buffer[pos + 5], buffer[pos + 6], buffer[pos + 7],
                ]) as u128;
                pos += 8;
                
                // Skip value type byte
                if pos >= buffer.len() { break; }
                let _value_type = buffer[pos];
                pos += 1;
                
                // Read title and content
                if let Some(key) = parse_string_encoding(&buffer, &mut pos) {
                    if let Some(value) = parse_string_encoding(&buffer, &mut pos) {
                        data_store.insert(key, StoredValue {
                            value,
                            expires_at: Some(expire_timestamp),
                        });
                    }
                }
            }
            0xFD => {
                // Entry with second expiration
                if pos + 4 > buffer.len() { break; }
                let expire_timestamp = u32::from_le_bytes([
                    buffer[pos], buffer[pos + 1], buffer[pos + 2], buffer[pos + 3],
                ]) as u128 * 1000; // Convert seconds to milliseconds
                pos += 4;
                
                // Skip value type byte
                if pos >= buffer.len() { break; }
                let _value_type = buffer[pos];
                pos += 1;
                
                // Read title and content
                if let Some(key) = parse_string_encoding(&buffer, &mut pos) {
                    if let Some(value) = parse_string_encoding(&buffer, &mut pos) {
                        data_store.insert(key, StoredValue {
                            value,
                            expires_at: Some(expire_timestamp),
                        });
                    }
                }
            }
            0xFF => {
                // End of file marker
                break;
            }
            _ => {
                // Regular entry without expiration
                let _value_type = opcode;
                
                // Read title and content
                if let Some(key) = parse_string_encoding(&buffer, &mut pos) {
                    if let Some(value) = parse_string_encoding(&buffer, &mut pos) {
                        data_store.insert(key, StoredValue {
                            value,
                            expires_at: None,
                        });
                    }
                }
            }
        }
    }
    
    data_store // Return the restored catalog
}

// üìã Library setup: Read administrative instructions from command line
fn parse_args() -> Config {
    let args: Vec<String> = env::args().collect();  // Get command line arguments
    // üìÅ Default library setup
    let mut dir = "/tmp/redis-data".to_string();
    let mut dbfilename = "dump.rdb".to_string();
    let mut port = 6379u16;  // Default library address (port 6379)
    let mut replicaof = None; // Default: main library (not a replica)
    
    let mut i = 1;
    while i < args.len() {
        // üìñ Read administrative instructions
        match args[i].as_str() {
            "--dir" => {
                // "Store archive files in this directory"
                if i + 1 < args.len() {
                    dir = args[i + 1].clone();
                    i += 2;
                } else {
                    i += 1;
                }
            }
            "--dbfilename" => {
                // "Name the archive file this"
                if i + 1 < args.len() {
                    dbfilename = args[i + 1].clone();
                    i += 2;
                } else {
                    i += 1;
                }
            }
            "--port" => {
                // "Open the library at this address/port"
                if i + 1 < args.len() {
                    if let Ok(parsed_port) = args[i + 1].parse::<u16>() {
                        port = parsed_port;  // Use custom address if valid
                    }
                    i += 2;
                } else {
                    i += 1;
                }
            }
            "--replicaof" => {
                // "Operate as a replica library, connecting to this master library"
                if i + 1 < args.len() {
                    let master_info = &args[i + 1];
                    let parts: Vec<&str> = master_info.split_whitespace().collect();
                    if parts.len() == 2 {
                        if let Ok(master_port) = parts[1].parse::<u16>() {
                            replicaof = Some((parts[0].to_string(), master_port));
                        }
                    }
                    i += 2;
                } else {
                    i += 1;
                }
            }
            _ => {
                i += 1;
            }
        }
    }
    
    Config { dir, dbfilename, port, replicaof }  // Return library configuration with address and master info
}

// üîó Library networking: Connect to master library for replica coordination
fn connect_to_master(master_host: &str, master_port: u16) -> Result<TcpStream, std::io::Error> {
    let master_address = format!("{}:{}", master_host, master_port);
    println!("Connecting to master library at {}", master_address);
    TcpStream::connect(master_address)
}

// üìû Opening handshake: Send greeting to master library when replica opens
fn send_ping_to_master(stream: &mut TcpStream) -> Result<(), std::io::Error> {
    // Send PING greeting as library protocol: *1\r\n$4\r\nPING\r\n
    let ping_command = b"*1\r\n$4\r\nPING\r\n";
    stream.write_all(ping_command)?;
    
    // Read master's response (should be +PONG\r\n)
    let mut buffer = [0; 1024];
    let _n = stream.read(&mut buffer)?;
    // Response processing not needed for basic handshake
    
    println!("Sent opening PING greeting to master library");
    Ok(())
}

// üìã Branch registration: Tell master what port this branch operates on
fn send_replconf_listening_port(stream: &mut TcpStream, port: u16) -> Result<(), std::io::Error> {
    // Send branch address registration: REPLCONF listening-port <PORT>
    // Format: *3\r\n$8\r\nREPLCONF\r\n$14\r\nlistening-port\r\n$4\r\n6380\r\n
    let port_str = port.to_string();
    let command = format!(
        "*3\r\n$8\r\nREPLCONF\r\n$14\r\nlistening-port\r\n${}\r\n{}\r\n",
        port_str.len(),
        port_str
    );
    stream.write_all(command.as_bytes())?;
    
    // Read master's acknowledgment (should be +OK\r\n)
    let mut buffer = [0; 1024];
    let _n = stream.read(&mut buffer)?;
    
    println!("Registered branch address with master library");
    Ok(())
}

// üéØ Capability announcement: Tell master what services this branch supports
fn send_replconf_capa_psync2(stream: &mut TcpStream) -> Result<(), std::io::Error> {
    // Send capability announcement: REPLCONF capa psync2
    // Format: *3\r\n$8\r\nREPLCONF\r\n$4\r\ncapa\r\n$6\r\npsync2\r\n
    let command = b"*3\r\n$8\r\nREPLCONF\r\n$4\r\ncapa\r\n$6\r\npsync2\r\n";
    stream.write_all(command)?;
    
    // Read master's acknowledgment (should be +OK\r\n)
    let mut buffer = [0; 1024];
    let _n = stream.read(&mut buffer)?;
    
    println!("Announced branch capabilities to master library");
    Ok(())
}

// üìö Full catalog synchronization: Request complete collection sync from master library
fn send_psync_to_master(stream: &mut TcpStream) -> Result<(), std::io::Error> {
    // Send synchronization request: PSYNC ? -1 (? = "I'm a new branch, no previous sync ID", -1 = "start from beginning")
    // Format: *3\r\n$5\r\nPSYNC\r\n$1\r\n?\r\n$2\r\n-1\r\n
    let command = b"*3\r\n$5\r\nPSYNC\r\n$1\r\n?\r\n$2\r\n-1\r\n";
    stream.write_all(command)?;
    
    // Read master's response (should be +FULLRESYNC <REPL_ID> 0\r\n)
    let mut buffer = [0; 1024];
    let _n = stream.read(&mut buffer)?;
    // Response processing will be implemented in future library system updates
    
    println!("Requested complete catalog synchronization from master library");
    Ok(())
}

fn main() {
    // üìã Read administrative instructions and set up library configuration
    let config = parse_args();
    
    // üîó If this is a replica library, connect to master and perform full opening handshake
    if let Some((master_host, master_port)) = &config.replicaof {
        match connect_to_master(master_host, *master_port) {
            Ok(mut master_stream) => {
                // Step 1: Send greeting
                if let Err(e) = send_ping_to_master(&mut master_stream) {
                    println!("Failed to send opening greeting to master library: {}", e);
                    return;
                }
                
                // Step 2: Register branch address
                if let Err(e) = send_replconf_listening_port(&mut master_stream, config.port) {
                    println!("Failed to register branch address with master library: {}", e);
                    return;
                }
                
                // Step 3: Announce branch capabilities
                if let Err(e) = send_replconf_capa_psync2(&mut master_stream) {
                    println!("Failed to announce branch capabilities to master library: {}", e);
                    return;
                }
                
                // Step 4: Request complete catalog synchronization
                if let Err(e) = send_psync_to_master(&mut master_stream) {
                    println!("Failed to request catalog synchronization from master library: {}", e);
                    return;
                }
            }
            Err(e) => {
                println!("Failed to connect to master library: {}", e);
            }
        }
    }
    
    // üèõÔ∏è Open the library at the configured address (default 6379, or custom via --port)
    let bind_address = format!("127.0.0.1:{}", config.port);
    let listener = TcpListener::bind(&bind_address).unwrap();
    // üóÉÔ∏è Load previous collection from archive file (if it exists) - library remembers its collection!
    let initial_data = load_rdb_file(&config);
    // üìö Create the library's shared catalog with any restored collection (thread-safe storage)
    let data_store = Arc::new(Mutex::new(initial_data));

    // üö™ Wait for visitors to enter the library
    for stream in listener.incoming() {
        match stream {
            // ‚úÖ A visitor successfully entered
            Ok(mut stream) => {
                // üîë Give the librarian access to the catalog
                let store_clone = Arc::clone(&data_store);
                // üìã Give the librarian a copy of the library configuration
                let config_clone = config.clone();
                // üë©‚Äçüè´ Assign a dedicated librarian to this visitor
                thread::spawn(move || {
                    let mut buffer = [0; 1024];  // Librarian's notepad
                    
                    // üîÑ Keep helping this visitor
                    loop {
                        // üëÇ Listen to what the visitor needs
                        match stream.read(&mut buffer) {
                            Ok(0) => break,  // Visitor left
                            Ok(n) => {
                                // üß† Try to understand what they requested using special training
                                if let Some(args) = parse_redis_command(&buffer, n) {
                                    if !args.is_empty() {
                                        let command = args[0].to_uppercase();  // Commands are case-insensitive
                                        
                                        // üìö Provide service based on what they requested
                                        match command.as_str() {
                                            "PING" => {
                                                // Simple request: just respond "PONG"
                                                stream.write_all(b"+PONG\r\n").unwrap();
                                            }
                                            "ECHO" => {
                                                // Echo request: repeat back what they said
                                                if args.len() > 1 {
                                                    let arg = &args[1];
                                                    // Format response as: $length\r\nvalue\r\n
                                                    let response = format!("${}\r\n{}\r\n", arg.len(), arg);
                                                    stream.write_all(response.as_bytes()).unwrap();
                                                }
                                            }
                                            "SET" => {
                                                // üìù Visitor wants to add something to the collection: "SET title content" or "SET title content px 100"
                                                if args.len() >= 3 {
                                                    let key = &args[1];
                                                    let value = &args[2];
                                                    
                                                    let mut expires_at = None;
                                                    
                                                    // üïê Check if visitor wants expiration timer: "px 100" means "expires in 100 milliseconds"
                                                    if args.len() >= 5 {
                                                        let option = args[3].to_uppercase();
                                                        if option == "PX" {
                                                            if let Ok(ms) = args[4].parse::<u128>() {
                                                                // üïê Set library's timer: current time + expiration time
                                                                let now = SystemTime::now()
                                                                    .duration_since(UNIX_EPOCH)
                                                                    .unwrap()
                                                                    .as_millis();
                                                                expires_at = Some(now + ms);
                                                            }
                                                        }
                                                    }
                                                    
                                                    // üóÇÔ∏è Create catalog entry with content and optional timer
                                                    let stored_value = StoredValue {
                                                        value: value.clone(),
                                                        expires_at,
                                                    };
                                                    
                                                    // üîí Lock the catalog so only this librarian can write
                                                    let mut store = store_clone.lock().unwrap();
                                                    // üìñ Add the entry to the catalog
                                                    store.insert(key.clone(), stored_value);
                                                    // ‚úÖ Tell visitor "OK, I've cataloged it!"
                                                    stream.write_all(b"+OK\r\n").unwrap();
                                                }
                                            }
                                            "GET" => {
                                                // üîç Visitor wants to retrieve something: "GET title"
                                                if args.len() >= 2 {
                                                    let key = &args[1];
                                                    // üîí Lock the catalog to read/write safely (might need to remove expired items)
                                                    let mut store = store_clone.lock().unwrap();
                                                    
                                                    match store.get(key) {
                                                        Some(stored_value) => {
                                                            // üïê Check if this exhibit has expired
                                                            if let Some(expires_at) = stored_value.expires_at {
                                                                let now = SystemTime::now()
                                                                    .duration_since(UNIX_EPOCH)
                                                                    .unwrap()
                                                                    .as_millis();
                                                                
                                                                if now >= expires_at {
                                                                    // ‚è∞ Exhibition ended! Remove it and say "not found"
                                                                    store.remove(key);
                                                                    stream.write_all(b"$-1\r\n").unwrap();
                                                                } else {
                                                                    // üìñ Still available! Provide the content
                                                                    let response = format!("${}\r\n{}\r\n", stored_value.value.len(), stored_value.value);
                                                                    stream.write_all(response.as_bytes()).unwrap();
                                                                }
                                                            } else {
                                                                // üìñ No timer, permanent collection - provide the content
                                                                let response = format!("${}\r\n{}\r\n", stored_value.value.len(), stored_value.value);
                                                                stream.write_all(response.as_bytes()).unwrap();
                                                            }
                                                        }
                                                        None => {
                                                            // ü§∑ Not found, tell them it doesn't exist
                                                            stream.write_all(b"$-1\r\n").unwrap();
                                                        }
                                                    }
                                                }
                                            }
                                            "CONFIG" => {
                                                // üìã Visitor asking about library configuration: "CONFIG GET dir" or "CONFIG GET dbfilename"
                                                if args.len() >= 3 && args[1].to_uppercase() == "GET" {
                                                    let param = &args[2];  // What configuration they want to know
                                                    match param.to_lowercase().as_str() {
                                                        "dir" => {
                                                            // üìÅ "Where do you store archive files?"
                                                            let response = format!("*2\r\n$3\r\ndir\r\n${}\r\n{}\r\n", 
                                                                config_clone.dir.len(), config_clone.dir);
                                                            stream.write_all(response.as_bytes()).unwrap();
                                                        }
                                                        "dbfilename" => {
                                                            // üóÇÔ∏è "What's the archive file called?"
                                                            let response = format!("*2\r\n$10\r\ndbfilename\r\n${}\r\n{}\r\n", 
                                                                config_clone.dbfilename.len(), config_clone.dbfilename);
                                                            stream.write_all(response.as_bytes()).unwrap();
                                                        }
                                                        _ => {
                                                            // ü§∑ Don't know that configuration setting
                                                            stream.write_all(b"*0\r\n").unwrap();
                                                        }
                                                    }
                                                }
                                            }
                                            "KEYS" => {
                                                // üîç Visitor wants to browse what's available: "KEYS *" (show all) or "KEYS title" (show titles matching "title")
                                                if args.len() >= 2 {
                                                    let pattern = &args[1];
                                                    // üîí Lock the catalog to read current collection
                                                    let store = store_clone.lock().unwrap();
                                                    let now = SystemTime::now()
                                                        .duration_since(UNIX_EPOCH)
                                                        .unwrap()
                                                        .as_millis();
                                                    
                                                    let mut matching_keys = Vec::new();
                                                    
                                                    // üîç Look through all items in the catalog
                                                    for (key, stored_value) in store.iter() {
                                                        // ‚è∞ Check if this exhibit has expired
                                                        let is_expired = if let Some(expires_at) = stored_value.expires_at {
                                                            now >= expires_at
                                                        } else {
                                                            false
                                                        };
                                                        
                                                        // ‚úÖ If not expired and matches the pattern, add to list
                                                        if !is_expired && matches_pattern(key, pattern) {
                                                            matching_keys.push(key.clone());
                                                        }
                                                    }
                                                    
                                                    // üìù Format response as library catalog: *2\r\n$5\r\ntitle1\r\n$5\r\ntitle2\r\n
                                                    let mut response = format!("*{}\r\n", matching_keys.len());
                                                    for key in matching_keys {
                                                        response.push_str(&format!("${}\r\n{}\r\n", key.len(), key));
                                                    }
                                                    stream.write_all(response.as_bytes()).unwrap();
                                                } else {
                                                    // No pattern provided, return empty list
                                                    stream.write_all(b"*0\r\n").unwrap();
                                                }
                                            }
                                            "REPLCONF" => {
                                                // üìã Branch coordination: Handle messages from replica libraries
                                                // When a branch library sends status reports to the main library,
                                                // the main library needs to acknowledge receipt properly
                                                // This includes branch address registrations and capability announcements
                                                stream.write_all(b"+OK\r\n").unwrap(); // "Message received and acknowledged"
                                            }
                                            "INFO" => {
                                                // üìä Visitor wants to know about the library's status: "INFO replication"
                                                if args.len() >= 2 && args[1].to_lowercase() == "replication" {
                                                    // üèõÔ∏è Tell them what kind of library this is
                                                    let role = if config_clone.replicaof.is_some() {
                                                        "slave"  // This is a replica library
                                                    } else {
                                                        "master"  // This is the main library
                                                    };
                                                    let mut info_lines = vec![format!("role:{}", role)];
                                                    
                                                    // üÜî If this is a main library, provide replication tracking info
                                                    if config_clone.replicaof.is_none() {
                                                        info_lines.push("master_replid:8371b4fb1155b71f4a04d3e1bc3e18c4a990aeeb".to_string());
                                                        info_lines.push("master_repl_offset:0".to_string());
                                                    }
                                                    
                                                    let info_response = info_lines.join("\r\n");
                                                    let response = format!("${}\r\n{}\r\n", info_response.len(), info_response);
                                                    stream.write_all(response.as_bytes()).unwrap();
                                                }
                                            }
                                            _ => {
                                                // Unknown request: default to PONG
                                                stream.write_all(b"+PONG\r\n").unwrap();
                                            }
                                        }
                                    }
                                } else {
                                    // ü§∑ Couldn't understand the request format, default to PONG
                                    stream.write_all(b"+PONG\r\n").unwrap();
                                }
                            }
                            Err(e) => {
                                // üòµ Something went wrong with this visitor
                                println!("error reading from stream: {}", e);
                                break;  // Stop serving them
                            }
                        }
                    }
                });  // End of librarian's job
            }
            // ‚ùå Someone tried to enter but couldn't
            Err(e) => {
                println!("error: {}", e);
            }
        }
    }  // Keep waiting for more visitors
}
```

**Key Insights:**
1. **Each `thread::spawn` creates a new librarian** who can work independently, so the library can serve many visitors simultaneously instead of one at a time!

2. **The `parse_redis_command` function is like librarian training** - it teaches librarians how to decode the library's structured request format (Redis RESP protocol).

3. **The library now has a proper service system** - different requests (`PING`, `ECHO`, `SET`, `GET`) get different responses, making it much more useful than just saying "PONG" to everything!

4. **Smart fallback system** - if a librarian can't understand a request, they default to the simple "PONG" response rather than failing.

5. **The catalog (`HashMap`) is shared safely** - `Arc<Mutex<>>` ensures multiple librarians can access the same catalog without conflicts:
   - `Arc` = Multiple librarians can have a "reference" to the same catalog
   - `Mutex` = Only one librarian can read/write in the catalog at a time (prevents data corruption)

6. **Thread-safe catalog operations**:
   - `SET`: Librarian locks the catalog, adds the entry, unlocks, confirms "OK"
   - `SET` with timer: Same as above, but also sets an expiration timer
   - `GET`: Librarian locks the catalog, checks if expired (removes if so), provides the content (or "not found")

7. **Smart expiration system** - like temporary exhibitions that automatically close:
   - `StoredValue` struct holds both the content and optional expiration time
   - When storing: `SET title content px 100` sets a 100ms timer using the library's clock
   - When retrieving: GET checks the timer first - if expired, removes the item and says "not found"
   - Timer precision: Uses milliseconds since Unix epoch for accurate timing

8. **Library Configuration System** - like setting up the library's archival system:
   - `Config` struct stores where the library keeps its archive files
   - `parse_args()` reads the command line (like administrative instructions): `--dir /tmp/library-archives --dbfilename catalog.rdb`
   - The library now knows where to store its permanent records for persistence
   - `CONFIG GET` command lets visitors ask: "Where do you keep your archive files?"
   - Librarians can answer questions about the library's setup using the `CONFIG` command

9. **RDB Persistence System** - like the library's backup and restore system:
   - `load_rdb_file()` runs when the library opens to restore previous collection from archive files
   - Can read the special RDB file format with different sections (header, metadata, database, end-of-file)
   - Supports both length encoding and string encoding to decode the archive format
   - Handles entries with expiration times (both seconds and milliseconds)
   - If archive file doesn't exist or is corrupted, library starts fresh with empty catalog
   - Library can now remember its collection even after closing and reopening!

10. **KEYS Command System** - like showing visitors the current catalog:
   - `KEYS *` shows all non-expired items currently in the library's catalog
   - `KEYS pattern` supports simple pattern matching (exact matches or "*" for everything)
   - `matches_pattern()` function determines if a title matches what the visitor searched for
   - Automatically filters out expired exhibits - visitors only see what's currently available
   - Returns results in library format: `*2\r\n$6\r\ntitle1\r\n$6\r\ntitle2\r\n`

11. **Port Configuration System** - like opening multiple library branches:
   - `Config` struct now includes `port: u16` field to store the library's address
   - `parse_args()` reads `--port` flag from command line: `./library --port 6380`
   - Default port is 6379 (standard Redis port), but can be customized for any valid port number
   - `bind_address` is dynamically created: `format!("127.0.0.1:{}", config.port)`
   - This enables running multiple library branches simultaneously for distributed access:
     - Main library: `./library` (operates on port 6379)
     - Branch library: `./library --port 6380` (operates on port 6380)
   - Each library operates independently but can share the same system
   - Essential for distributed library systems where multiple locations need different addresses

12. **INFO Command System** - like the library's information desk:
   - `INFO replication` provides status information about the library's role and replication state
   - Reports `role:master` with `master_replid` and `master_repl_offset` for main library
   - Reports `role:slave` for replica library (without additional replication fields)
   - Master library includes tracking information:
     - `master_replid`: 40-character ID identifying this library instance (like a unique library serial number)
     - `master_repl_offset`: Tracks how many changes have been made (starts at 0, like a change counter)
   - Response format: Multi-line for master: `$N\r\nrole:master\r\nmaster_replid:...\r\nmaster_repl_offset:0\r\n`
   - Essential for library coordination - other systems can ask "What kind of library are you and what's your status?"
   - Like asking the information desk: "Is this the main library, and if so, what's your tracking info for synchronization?"

13. **Replica Configuration System** - like setting up a branch library:
   - `--replicaof "host port"` flag configures this library as a replica of another library
   - Example: `./library --port 6380 --replicaof "localhost 6379"` creates a replica on port 6380
   - `Config.replicaof` field stores master library information: `Some(("localhost", 6379))`
   - `parse_args()` parses the master info format: splits "localhost 6379" into host and port
   - INFO command automatically detects replica mode and reports `role:slave`
   - **NEW**: Replica libraries automatically perform opening handshake with master
   - Like opening a branch library that reports to the main headquarters

14. **Complete Opening Handshake System** - like new branch library introduction:
   - When replica library opens, it immediately connects to master library
   - `connect_to_master()` establishes connection to master library address
   - **Step 1**: `send_ping_to_master()` sends formal greeting: PING command as RESP format
   - **Step 2**: `send_replconf_listening_port()` registers branch address with master
   - **Step 3**: `send_replconf_capa_psync2()` announces branch capabilities
   - **Step 4**: `send_psync_to_master()` requests complete catalog synchronization from master
   - Each step waits for master's OK response before proceeding
   - Master library responds to each step to acknowledge the new branch
   - PSYNC command uses ? -1 format meaning "I'm a new branch, sync me from the beginning"
   - Master responds with FULLRESYNC and begins sending complete catalog data
   - Complete handshake uses proper library protocol throughout
   - Like a new branch calling headquarters: "Hello, we're at address 6380, we support psync2 synchronization, and please send us your complete catalog!"

15. **Master Branch Coordination Handling** - like headquarters managing branch reports:
   - Main libraries (masters) must handle messages from their branch libraries
   - When branch libraries send REPLCONF status reports, master acknowledges with +OK
   - Handles both "listening-port" address registrations and "capa" capability announcements
   - Like headquarters saying "Got your message, branch registered!" to each branch report
   - Ensures smooth two-way communication in the library network
   - Master library stays informed about all branch locations and their capabilities
   - **REPLCONF** command: Branch coordination messages ‚Üí "Message received and acknowledged" (branch management communication)

16. **Real-Time Collection Updates (Command Propagation)** - like instant catalog synchronization:
   - After PSYNC handshake completion, main library maintains active connections to all branch libraries
   - When visitors add items to the main library's collection (SET commands), these updates are immediately shared with all branches
   - `propagate_command_to_replicas()` formats collection updates as standard library messages and sends to all branch locations
   - Example: Visitor adds "SET book-title content" at main library ‚Üí all branches receive "*3\r\n$3\r\nSET\r\n$10\r\nbook-title\r\n$7\r\ncontent\r\n"
   - Only write operations (like SET) are propagated - read operations (like GET, PING) are handled locally at each branch
   - Branch libraries receive and process propagated updates silently (no response back to main library)
   - Automatic maintenance: disconnected branches are removed from the propagation list
   - Uses the same communication channel established during initial branch registration
   - Like main library calling all branches: "New item just added to collection - update your catalogs!"
   - Ensures all library locations stay synchronized with the same collection information

17. **Enhanced Branch Connection Management (Replica Connection Tracking)** - like maintaining branch communication directory:
   - `ReplicaConnections` type tracks all active branch communication channels
   - After PSYNC handshake, branch connections are stored for ongoing communication
   - `stream.try_clone()` creates dedicated communication channel for each branch
   - Propagation happens immediately after processing collection updates at main library (before confirming to visitor)
   - Error handling: branches that disconnect are automatically removed from updates
   - Thread-safe coordination ensures multiple visitors can add items simultaneously without conflicts
   - Like maintaining a phone directory of all branches for instant catalog updates

18. **Branch Processing Tracking System (REPLCONF GETACK with Offset)** - like detailed progress monitoring:
   - Main library can verify that branch libraries are processing all communications and staying synchronized
   - Each branch maintains a precise "processing counter" tracking the total size of all processed communications
   - Main library sends "REPLCONF GETACK *" to any branch (meaning "How many communications have you processed?")
   - Branch libraries respond with exact byte count: "REPLCONF ACK 146" (meaning "I've processed 146 bytes of communications and updates")

**Detailed Processing Tracking Implementation:**
   - Processing tracking works like this:
     - Branch starts with counter at 0
     - First GETACK arrives ‚Üí branch responds "ACK 0" then adds 37 bytes (size of that GETACK message)
     - Status ping arrives ‚Üí branch silently processes it and adds 14 bytes to counter
     - Next GETACK arrives ‚Üí branch responds "ACK 51" (37+14) then adds 37 more bytes
     - Catalog updates arrive ‚Üí branch processes and adds their byte sizes too
   - Example communication sequence:
     1. GETACK ‚Üí responds with "0", counter becomes 37
     2. Status ping (14 bytes) ‚Üí counter becomes 51
     3. GETACK ‚Üí responds with "51", counter becomes 88
     4. Catalog updates ‚Üí counter keeps growing with each processed communication

**Key Implementation Features:**
   - Like a branch keeping detailed records: "We've handled exactly 146 bytes worth of headquarters communications"
   - Counter includes ALL messages received from main library (GETACK, pings, catalog updates, etc.)
   - BUT each response only includes communications processed BEFORE the current GETACK request
   - Uses dynamic response format: `*3\r\n$8\r\nREPLCONF\r\n$3\r\nACK\r\n${len}\r\n{offset}\r\n`
   - Critical for main library to verify branches are processing all communications accurately
   - Helps detect if any branch has missed updates or fallen behind
   - Ensures quality control and synchronization across the entire library network

**Branch Communication Handler Implementation:**
   - Branch libraries maintain dedicated thread for main library communication
   - `replica_offset` variable tracks total bytes processed from main library
   - For each main library message:
     1. Calculate message byte size using `command_bytes.len()`
     2. Process the message (catalog updates, status pings, audit requests)
     3. Add message size to running offset total
   - GETACK responses use current offset (messages processed BEFORE this audit)
   - After sending GETACK response, add the audit message size to offset
   - Separate handling for different message types (SET updates catalog, PING confirms connection, GETACK provides audit)

**NEW TODAY: Advanced Service Coordination System**

**WAIT Command - Complete Quality Assurance Verification:**
The library now offers comprehensive verification services for visitors who want to ensure their updates have been properly distributed and confirmed by branch libraries:

**Basic WAIT Functionality:**
- "WAIT 0 60000" ‚Üí "Please confirm that 0 branch libraries have received my recent updates, wait up to 60 seconds"
- When requesting 0 confirmations, immediately returns 0 (no verification needed)
- When no catalog updates have been sent yet, immediately returns the number of connected branches

**Enhanced WAIT with Update Verification:**
- "WAIT 2 1000" ‚Üí "Please confirm that 2 branch libraries have processed my recent catalog updates, wait up to 1000 milliseconds"
- **Step 1**: Main library tracks every update sent to branches with precise byte counting (master offset tracking)
- **Step 2**: Main library sends "REPLCONF GETACK *" audit requests to all branch locations
- **Step 3**: Each branch responds with "REPLCONF ACK {offset}" showing how many update bytes they've processed
- **Step 4**: Main library counts how many branches have processed at least the recent update bytes
- **Step 5**: Returns actual number of synchronized branches within the timeout period

**Advanced Timeout Management:**
- Respects visitor's patience: won't wait longer than requested timeout
- Uses 1000ms timeout per branch for responses (reasonable wait time)
- Returns immediately when enough branches have confirmed
- Handles branch communication issues gracefully
- Maintains active branch connections for future communications

**Example Quality Assurance Flow:**
1. Visitor adds: "SET book-title content" ‚Üí update sent to 3 branches (31 bytes)
2. Visitor requests: "WAIT 2 500" ‚Üí "confirm 2 branches processed my book addition, wait max 500ms"
3. Main library asks branches: "GETACK *" ‚Üí "how many update bytes have you processed?"
4. Branch A responds: "ACK 31" ‚Üí "I've processed 31 bytes (including the book addition)"
5. Branch B responds: "ACK 31" ‚Üí "I've processed 31 bytes too"  
6. Branch C doesn't respond in time
7. Main library tells visitor: "2" ‚Üí "2 out of 3 branches confirmed your update"

**Business Value:**
- Visitors can verify critical catalog updates were distributed before leaving
- Ensures collection consistency across the library network
- Provides real-time branch synchronization status
- Helps detect branch communication problems quickly
- Critical for high-reliability library operations

**Enhanced Branch Processing - Multiple Instruction Handling:**
Branch libraries now have sophisticated instruction processing capabilities:
- Can receive and process multiple instructions in a single communication from headquarters
- Advanced parser detects multiple commands in one transmission: "SET book1 content1" + "SET book2 content2" + "SET book3 content3"
- Processes each instruction individually while maintaining accurate byte counting
- Prevents instruction loss when headquarters sends rapid updates
- Ensures all catalog updates are properly applied, even when sent in quick succession
- Critical fix that ensures no catalog entries are missed during busy periods

**Improved Communication Reliability:**
- Branch libraries now handle complex instruction sequences without losing connection
- Better error handling prevents communication breakdowns during high-traffic periods
- Enhanced buffer management ensures all instructions are processed correctly
- Maintains perfect synchronization even when receiving multiple simultaneous updates

**NEW: Reading List Management System (RPUSH Command)**

The library now offers advanced reading list management for organized book collections:

**Reading List Features:**
- RPUSH allows visitors to create and manage personalized reading lists: "RPUSH mystery-novels detective-story" (adds detective-story to mystery-novels list)
- Returns the total number of books in that reading list: ":1\r\n" for first book, ":2\r\n" for second book
- Each visitor can maintain multiple themed reading lists: fiction, non-fiction, research, etc.
- Reading lists are separate from the main catalog and work independently

**Implementation Details:**
- `reading_lists`: Separate HashMap<String, Vec<String>> for storing book lists
- Thread-safe access using Arc<Mutex<>> just like the main catalog
- RPUSH creates new lists automatically when they don't exist
- List names can be anything: subject areas, visitor names, project topics
- Perfect for academic research, themed collections, or personal organization

**Visitor Experience:**
- "RPUSH science-fiction dune" ‚Üí "1" (first book added to science-fiction list)
- "RPUSH science-fiction foundation" ‚Üí "2" (second book added to science-fiction list)
- "RPUSH science-fiction neuromancer" ‚Üí "3" (third book added to science-fiction list)
- Each list maintains perfect order for reading sequence

**Library Benefits:**
- Visitors can organize books by topic, project, or reading order
- Librarians can track how many books are in each themed collection
- Perfect for research projects requiring multiple related books
- Enables sophisticated collection management
- Works alongside existing catalog system (SET/GET) for maximum flexibility

The library system is now enterprise-ready - it can handle different services, manage temporary exhibitions with expiration times, support multiple branches with full two-way coordination, real-time collection synchronization, branch status monitoring, quality assurance verification, multiple instruction processing, reading list management, and respond appropriately to all visitor needs with maximum reliability!