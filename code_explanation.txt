Redis Server Code Explanation - Restaurant Analogy

This Redis server code works like a smart restaurant:

**The Restaurant (Server)**
- Opens on "127.0.0.1:6379" (like a restaurant address)
- Waits for customers (clients) to walk in

**When Customers Arrive**
- Each customer gets their own waiter (thread) 
- The waiter stays with that customer the entire time
- Multiple customers can be served simultaneously

**How Waiters Understand Orders (Redis Protocol Parser)**
The waiters now have a special training to understand customer orders! They can decode the restaurant's special ordering format:
- Customers don't just say "PING" - they speak in a structured way: `*2\r\n$4\r\nECHO\r\n$3\r\nhey\r\n`
- The waiter (parser) breaks this down:
  - `*2` = "This order has 2 parts"
  - `$4\r\nECHO` = "First part is 4 letters: ECHO"
  - `$3\r\nhey` = "Second part is 3 letters: hey"
- So the waiter understands: "Customer wants ECHO with argument 'hey'"

**What Each Waiter Does Now**
1. Listens to what the customer says (reads data)
2. **NEW**: Decodes the special restaurant language (Redis protocol)
3. **NEW**: Checks what the customer actually ordered:
   - If they say "PING" → responds "PONG" (simple string: `+PONG\r\n`)
   - If they say "ECHO [something]" → repeats back exactly what they said (bulk string: `$3\r\nhey\r\n`)
   - **If they say "SET [key] [value]" → stores it in the restaurant's memory book and says "OK"**
   - **If they say "GET [key]" → looks up the key in the memory book and tells them the value**
   - If they say something else → defaults to "PONG"
4. Keeps doing this until the customer leaves
5. If something goes wrong, the waiter stops serving that customer

**Key Benefits**
- Multiple customers can be served at once (concurrent connections)
- One slow customer doesn't block others
- Each conversation is independent
- **NEW**: Waiters can understand different types of orders!
- **NEW**: Responses are properly formatted in the restaurant's language
- **NEW**: The restaurant has a shared memory book that all waiters can access safely
- **NEW**: Customers can store and retrieve information (SET/GET commands)

The restaurant is now much smarter - it can handle different orders, remember things, and respond appropriately!

==== CODE WITH RESTAURANT COMMENTS ====

```rust
// Restaurant imports - tools we need
use std::collections::HashMap;  // The restaurant's memory book
use std::io::{Read, Write};     // For talking to customers
use std::net::TcpListener;      // The restaurant building
use std::sync::{Arc, Mutex};    // Safe way to share the memory book between waiters
use std::thread;                // Waiters

// 🧠 Special waiter training: How to understand customer orders
fn parse_redis_command(buffer: &[u8], n: usize) -> Option<Vec<String>> {
    let data = String::from_utf8_lossy(&buffer[..n]);
    let lines: Vec<&str> = data.split("\r\n").collect();
    
    // Check if it's a proper order format (*number means "order has X parts")
    if lines.is_empty() || !lines[0].starts_with('*') {
        return None;  // Can't understand this order
    }
    
    let array_len: usize = lines[0][1..].parse().ok()?;  // How many parts?
    let mut args = Vec::new();  // Collect order parts here
    let mut line_idx = 1;
    
    // Parse each part of the order
    for _ in 0..array_len {
        // Each part starts with $ and length ($4 means "next part is 4 letters")
        if line_idx >= lines.len() || !lines[line_idx].starts_with('$') {
            return None;  // Malformed order
        }
        
        let str_len: usize = lines[line_idx][1..].parse().ok()?;
        line_idx += 1;
        
        // Get the actual word
        if line_idx >= lines.len() {
            return None;
        }
        
        let arg = lines[line_idx].to_string();
        if arg.len() != str_len {
            return None;  // Length doesn't match
        }
        
        args.push(arg);  // Add this word to the order
        line_idx += 1;
    }
    
    Some(args)  // Return the understood order
}

fn main() {
    // 🏪 Open the restaurant at address "127.0.0.1:6379"
    let listener = TcpListener::bind("127.0.0.1:6379").unwrap();
    // 📖 Create the restaurant's shared memory book (thread-safe storage)
    let data_store = Arc::new(Mutex::new(HashMap::<String, String>::new()));

    // 🚪 Wait for customers to walk through the door
    for stream in listener.incoming() {
        match stream {
            // ✅ A customer successfully entered
            Ok(mut stream) => {
                // 🔑 Give the waiter a copy of the key to the memory book
                let store_clone = Arc::clone(&data_store);
                // 👨‍🍳 Assign a dedicated waiter to this customer
                thread::spawn(move || {
                    let mut buffer = [0; 1024];  // Waiter's notepad
                    
                    // 🔄 Keep serving this customer
                    loop {
                        // 👂 Listen to what the customer says
                        match stream.read(&mut buffer) {
                            Ok(0) => break,  // Customer left
                            Ok(n) => {
                                // 🧠 Try to understand what they ordered using special training
                                if let Some(args) = parse_redis_command(&buffer, n) {
                                    if !args.is_empty() {
                                        let command = args[0].to_uppercase();  // Commands are case-insensitive
                                        
                                        // 🍽️ Serve based on what they ordered
                                        match command.as_str() {
                                            "PING" => {
                                                // Simple order: just respond "PONG"
                                                stream.write_all(b"+PONG\r\n").unwrap();
                                            }
                                            "ECHO" => {
                                                // Echo order: repeat back what they said
                                                if args.len() > 1 {
                                                    let arg = &args[1];
                                                    // Format response as: $length\r\nvalue\r\n
                                                    let response = format!("${}\r\n{}\r\n", arg.len(), arg);
                                                    stream.write_all(response.as_bytes()).unwrap();
                                                }
                                            }
                                            "SET" => {
                                                // 📝 Customer wants to store something: "SET key value"
                                                if args.len() >= 3 {
                                                    let key = &args[1];
                                                    let value = &args[2];
                                                    // 🔒 Lock the memory book so only this waiter can write
                                                    let mut store = store_clone.lock().unwrap();
                                                    // 📖 Write the key-value pair in the book
                                                    store.insert(key.clone(), value.clone());
                                                    // ✅ Tell customer "OK, I wrote it down!"
                                                    stream.write_all(b"+OK\r\n").unwrap();
                                                }
                                            }
                                            "GET" => {
                                                // 🔍 Customer wants to retrieve something: "GET key"
                                                if args.len() >= 2 {
                                                    let key = &args[1];
                                                    // 🔒 Lock the memory book to read safely
                                                    let store = store_clone.lock().unwrap();
                                                    match store.get(key) {
                                                        Some(value) => {
                                                            // 📖 Found it! Tell them the value
                                                            let response = format!("${}\r\n{}\r\n", value.len(), value);
                                                            stream.write_all(response.as_bytes()).unwrap();
                                                        }
                                                        None => {
                                                            // 🤷 Not found, tell them it doesn't exist
                                                            stream.write_all(b"$-1\r\n").unwrap();
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {
                                                // Unknown order: default to PONG
                                                stream.write_all(b"+PONG\r\n").unwrap();
                                            }
                                        }
                                    }
                                } else {
                                    // 🤷 Couldn't understand the order format, default to PONG
                                    stream.write_all(b"+PONG\r\n").unwrap();
                                }
                            }
                            Err(e) => {
                                // 😵 Something went wrong with this customer
                                println!("error reading from stream: {}", e);
                                break;  // Stop serving them
                            }
                        }
                    }
                });  // End of waiter's job
            }
            // ❌ Someone tried to enter but couldn't
            Err(e) => {
                println!("error: {}", e);
            }
        }
    }  // Keep waiting for more customers
}
```

**Key Insights:**
1. **Each `thread::spawn` creates a new waiter** who can work independently, so the restaurant can serve many customers simultaneously instead of one at a time!

2. **The `parse_redis_command` function is like waiter training** - it teaches waiters how to decode the restaurant's special ordering language (Redis RESP protocol).

3. **The restaurant now has a proper menu system** - different orders (`PING`, `ECHO`, `SET`, `GET`) get different responses, making it much more useful than just saying "PONG" to everything!

4. **Smart fallback system** - if a waiter can't understand an order, they default to the simple "PONG" response rather than breaking.

5. **The memory book (`HashMap`) is shared safely** - `Arc<Mutex<>>` ensures multiple waiters can access the same memory book without conflicts:
   - `Arc` = Multiple waiters can have a "reference" to the same book
   - `Mutex` = Only one waiter can read/write in the book at a time (prevents data corruption)

6. **Thread-safe storage operations**:
   - `SET`: Waiter locks the book, writes the key-value pair, unlocks, says "OK"
   - `GET`: Waiter locks the book, looks up the key, unlocks, tells customer the value (or "not found")