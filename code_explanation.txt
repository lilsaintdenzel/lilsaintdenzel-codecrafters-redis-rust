Redis Server Implementation - Technical Code Explanation

This Redis server is implemented in Rust and supports core Redis functionality including replication roles.

=== MAIN COMPONENTS ===

**1. Data Structures**

```rust
#[derive(Clone)]
struct StoredValue {
    value: String,              // The stored data
    expires_at: Option<u128>,   // Expiration timestamp in milliseconds since epoch
}

#[derive(Clone)]
struct Config {
    dir: String,                // Directory for RDB files
    dbfilename: String,         // RDB filename
    port: u16,                  // Server port
    replicaof: Option<(String, u16)>, // Master server info for replication (host, port)
}
```

**StoredValue**: Represents data with optional TTL support
**Config**: Server configuration including replication settings

**2. Command Line Parsing**

```rust
fn parse_args() -> Config
```

Parses command line arguments:
- `--dir <path>`: Sets RDB file directory
- `--dbfilename <name>`: Sets RDB filename
- `--port <port>`: Sets server port (default 6379)
- `--replicaof "<host> <port>"`: Configures server as replica

The `--replicaof` parsing:
1. Takes argument like "localhost 6379"
2. Splits by whitespace into host and port
3. Validates port as u16
4. Stores as `Some((host, port))` in Config

**3. Redis Protocol Parser**

```rust
fn parse_redis_command(buffer: &[u8], n: usize) -> Option<Vec<String>>
```

Implements RESP (Redis Serialization Protocol) parsing:
- Parses array format: `*2\r\n$4\r\nECHO\r\n$5\r\nhello\r\n`
- `*N` = array with N elements
- `$L` = bulk string with length L
- Returns Vec<String> with command and arguments

**4. RDB File Loading**

```rust
fn load_rdb_file(config: &Config) -> HashMap<String, StoredValue>
```

Loads persistence data on startup:
- Reads binary RDB format
- Handles length encoding and string encoding
- Supports expiration timestamps (both seconds and milliseconds)
- Gracefully handles missing/corrupted files

**5. Core Server Logic**

```rust
fn main()
```

Server architecture:
1. **Single-threaded listener**: Accepts connections on configured port
2. **Multi-threaded handlers**: Each client gets dedicated thread
3. **Shared state**: `Arc<Mutex<HashMap>>` for thread-safe data access
4. **Configuration sharing**: Each thread gets Config clone

**6. Command Implementations**

**PING**: Returns `+PONG\r\n`

**ECHO**: Returns bulk string with argument

**SET**: 
- Basic: `SET key value` stores permanently
- With TTL: `SET key value PX milliseconds` stores with expiration
- Uses system time + offset for expiration calculation

**GET**:
- Checks expiration before returning
- Removes expired keys automatically
- Returns `$-1\r\n` for missing/expired keys

**CONFIG GET**:
- `CONFIG GET dir` returns directory setting
- `CONFIG GET dbfilename` returns filename setting
- Returns array format: `*2\r\n$3\r\ndir\r\n$<len>\r\n<value>\r\n`

**KEYS**:
- Pattern matching (currently supports "*" and exact matches)
- Filters expired keys automatically
- Returns array of matching keys

**INFO**:
- `INFO replication` returns role information
- Returns `role:master` for normal operation
- Returns `role:slave` when `--replicaof` is configured
- Role determination: `config.replicaof.is_some() ? "slave" : "master"`

=== REPLICATION IMPLEMENTATION ===

**Role Detection**:
```rust
let role = if config_clone.replicaof.is_some() {
    "slave"
} else {
    "master"
};
```

**Current Status**:
- ✅ Command-line parsing for `--replicaof` flag
- ✅ Role reporting via INFO command
- ❌ Actual connection to master (future implementation)
- ❌ Data synchronization (future implementation)

**Example Usage**:
```bash
# Master mode (default)
./redis-server --port 6379

# Replica mode
./redis-server --port 6380 --replicaof "localhost 6379"
```

=== TECHNICAL DETAILS ===

**Thread Safety**:
- `Arc<Mutex<HashMap>>` provides shared, thread-safe storage
- Each command locks mutex only during data access
- Minimizes lock contention with quick operations

**Memory Management**:
- Automatic cleanup of expired keys during GET operations
- Clone-on-thread-spawn for configuration sharing
- No memory leaks due to Rust ownership system

**Error Handling**:
- Graceful degradation for protocol parsing errors
- Default PONG response for unrecognized commands
- File I/O errors handled with empty data store fallback

**Protocol Compliance**:
- Implements RESP protocol correctly
- Proper bulk string formatting with lengths
- Correct array formatting for multi-element responses

**Performance Characteristics**:
- O(1) key lookups in HashMap
- O(n) KEYS command (scans all keys)
- Thread-per-connection model (suitable for moderate concurrency)

=== CURRENT LIMITATIONS ===

1. **Replication**: Only reports role, doesn't sync data
2. **Pattern Matching**: KEYS only supports "*" and exact matches  
3. **RDB Writing**: Only reads RDB files, doesn't write them
4. **Pub/Sub**: Not implemented
5. **Transactions**: Not implemented
6. **Lua Scripting**: Not implemented

=== TESTING ===

The server can be tested with redis-cli:

```bash
# Test master mode
redis-cli -p 6379 INFO replication
# Expected: role:master

# Test replica mode  
redis-cli -p 6380 INFO replication  
# Expected: role:slave

# Test other commands
redis-cli -p 6379 SET key value
redis-cli -p 6379 GET key
redis-cli -p 6379 KEYS "*"
```

This implementation provides a solid foundation for a Redis server with proper replication role support and can be extended with actual replication logic in future iterations.