Redis Server Implementation - Technical Code Explanation

This Redis server is implemented in Rust and supports core Redis functionality including replication with master identification and offset tracking.

=== COMPLETE CODE WITH DETAILED COMMENTS ===

```rust
#![allow(unused_imports)]
use std::collections::HashMap;  // Key-value storage for data
use std::env;                   // Command line argument parsing
use std::fs::File;              // File I/O for RDB persistence
use std::io::{BufReader, Read, Write}; // Stream I/O operations
use std::net::TcpListener;      // TCP server functionality
use std::path::Path;            // File path operations
use std::sync::{Arc, Mutex};    // Thread-safe shared state
use std::thread;                // Multi-threading support
use std::time::{SystemTime, UNIX_EPOCH}; // Time operations for TTL

// Data structure for stored values with optional expiration
#[derive(Clone)]
struct StoredValue {
    value: String,              // The actual stored data
    expires_at: Option<u128>,   // Optional expiration timestamp (milliseconds since epoch)
}

// Server configuration structure
#[derive(Clone)]
struct Config {
    dir: String,                // Directory for RDB files
    dbfilename: String,         // RDB filename
    port: u16,                  // Server port
    replicaof: Option<(String, u16)>, // Master server info for replication (host, port)
}

// Redis RESP protocol parser - converts incoming bytes to command arguments
fn parse_redis_command(buffer: &[u8], n: usize) -> Option<Vec<String>> {
    let data = String::from_utf8_lossy(&buffer[..n]);
    let lines: Vec<&str> = data.split("\r\n").collect();
    
    // Check for array format: *N indicates N elements follow
    if lines.is_empty() || !lines[0].starts_with('*') {
        return None;
    }
    
    let array_len: usize = lines[0][1..].parse().ok()?; // Parse number of arguments
    let mut args = Vec::new();
    let mut line_idx = 1;
    
    // Parse each argument in the array
    for _ in 0..array_len {
        // Each argument starts with $L where L is the length
        if line_idx >= lines.len() || !lines[line_idx].starts_with('$') {
            return None;
        }
        
        let str_len: usize = lines[line_idx][1..].parse().ok()?; // Parse argument length
        line_idx += 1;
        
        // Get the actual argument string
        if line_idx >= lines.len() {
            return None;
        }
        
        let arg = lines[line_idx].to_string();
        if arg.len() != str_len {
            return None; // Length mismatch
        }
        
        args.push(arg);
        line_idx += 1;
    }
    
    Some(args) // Return parsed command and arguments
}

// RDB length encoding parser - handles variable-length integer encoding
fn parse_length_encoding(bytes: &[u8], pos: &mut usize) -> Option<u64> {
    if *pos >= bytes.len() {
        return None;
    }
    
    let first_byte = bytes[*pos];
    *pos += 1;
    
    // First two bits determine encoding type
    let first_two_bits = (first_byte & 0b11000000) >> 6;
    
    match first_two_bits {
        0b00 => {
            // 6-bit length: remaining bits contain the value
            Some((first_byte & 0b00111111) as u64)
        }
        0b01 => {
            // 14-bit length: combine with next byte
            if *pos >= bytes.len() {
                return None;
            }
            let second_byte = bytes[*pos];
            *pos += 1;
            let length = (((first_byte & 0b00111111) as u64) << 8) | (second_byte as u64);
            Some(length)
        }
        0b10 => {
            // 32-bit length: next 4 bytes (big-endian)
            if *pos + 4 > bytes.len() {
                return None;
            }
            let mut length = 0u64;
            for i in 0..4 {
                length = (length << 8) | (bytes[*pos + i] as u64);
            }
            *pos += 4;
            Some(length)
        }
        0b11 => {
            // Special encoding marker for integer values
            Some(0xFF00 | ((first_byte & 0b00111111) as u64))
        }
        _ => None,
    }
}

// RDB string encoding parser - handles strings and encoded integers
fn parse_string_encoding(bytes: &[u8], pos: &mut usize) -> Option<String> {
    let length_or_type = parse_length_encoding(bytes, pos)?;
    
    if length_or_type >= 0xFF00 {
        // Special integer encoding
        let encoding_type = (length_or_type & 0xFF) as u8;
        match encoding_type {
            0x00 => {
                // 8-bit signed integer
                if *pos >= bytes.len() {
                    return None;
                }
                let val = bytes[*pos] as i8;
                *pos += 1;
                Some(val.to_string())
            }
            0x01 => {
                // 16-bit signed integer (little-endian)
                if *pos + 2 > bytes.len() {
                    return None;
                }
                let val = u16::from_le_bytes([bytes[*pos], bytes[*pos + 1]]) as i16;
                *pos += 2;
                Some(val.to_string())
            }
            0x02 => {
                // 32-bit signed integer (little-endian)
                if *pos + 4 > bytes.len() {
                    return None;
                }
                let val = u32::from_le_bytes([
                    bytes[*pos],
                    bytes[*pos + 1],
                    bytes[*pos + 2],
                    bytes[*pos + 3],
                ]) as i32;
                *pos += 4;
                Some(val.to_string())
            }
            _ => None,
        }
    } else {
        // Regular string: read specified number of bytes
        let len = length_or_type as usize;
        if *pos + len > bytes.len() {
            return None;
        }
        let string_bytes = &bytes[*pos..*pos + len];
        *pos += len;
        String::from_utf8(string_bytes.to_vec()).ok()
    }
}

// Pattern matching for KEYS command - supports wildcards
fn matches_pattern(key: &str, pattern: &str) -> bool {
    if pattern == "*" {
        return true; // Match all keys
    }
    
    // Simple glob pattern matching
    if pattern.contains('*') {
        if pattern == "*" {
            return true;
        }
        // More complex pattern matching could be implemented here
        true
    } else {
        key == pattern // Exact match only
    }
}

// RDB file loader - restores data from persistence file on startup
fn load_rdb_file(config: &Config) -> HashMap<String, StoredValue> {
    let mut data_store = HashMap::new();
    let rdb_path = Path::new(&config.dir).join(&config.dbfilename);
    
    // Check if RDB file exists
    if !rdb_path.exists() {
        return data_store; // Return empty store if file doesn't exist
    }
    
    // Open and read RDB file
    let file = match File::open(&rdb_path) {
        Ok(f) => f,
        Err(_) => return data_store, // Return empty store on error
    };
    
    let mut reader = BufReader::new(file);
    let mut buffer = Vec::new();
    if reader.read_to_end(&mut buffer).is_err() {
        return data_store; // Return empty store if can't read file
    }
    
    let mut pos = 0;
    
    // Validate RDB file header (should be "REDIS" + version)
    if buffer.len() < 9 || &buffer[0..5] != b"REDIS" {
        return data_store;
    }
    pos = 9; // Skip header
    
    // Parse RDB file sections
    while pos < buffer.len() {
        let opcode = buffer[pos]; // Section type marker
        pos += 1;
        
        match opcode {
            0xFA => {
                // Metadata section - skip
                if let Some(_key) = parse_string_encoding(&buffer, &mut pos) {
                    let _value = parse_string_encoding(&buffer, &mut pos);
                }
            }
            0xFE => {
                // Database selector
                let _db_index = parse_length_encoding(&buffer, &mut pos);
            }
            0xFB => {
                // Hash table size information - skip
                let _hash_table_size = parse_length_encoding(&buffer, &mut pos);
                let _expire_hash_table_size = parse_length_encoding(&buffer, &mut pos);
            }
            0xFC => {
                // Key-value pair with millisecond expiration
                if pos + 8 > buffer.len() {
                    break;
                }
                // Read 8-byte timestamp (little-endian)
                let expire_timestamp = u64::from_le_bytes([
                    buffer[pos],
                    buffer[pos + 1],
                    buffer[pos + 2],
                    buffer[pos + 3],
                    buffer[pos + 4],
                    buffer[pos + 5],
                    buffer[pos + 6],
                    buffer[pos + 7],
                ]) as u128;
                pos += 8;
                
                // Skip value type byte
                if pos >= buffer.len() {
                    break;
                }
                let _value_type = buffer[pos];
                pos += 1;
                
                // Parse key and value
                if let Some(key) = parse_string_encoding(&buffer, &mut pos) {
                    if let Some(value) = parse_string_encoding(&buffer, &mut pos) {
                        data_store.insert(
                            key,
                            StoredValue {
                                value,
                                expires_at: Some(expire_timestamp),
                            },
                        );
                    }
                }
            }
            0xFD => {
                // Key-value pair with second expiration
                if pos + 4 > buffer.len() {
                    break;
                }
                // Read 4-byte timestamp (little-endian) and convert to milliseconds
                let expire_timestamp = u32::from_le_bytes([
                    buffer[pos],
                    buffer[pos + 1],
                    buffer[pos + 2],
                    buffer[pos + 3],
                ]) as u128
                    * 1000; // Convert seconds to milliseconds
                pos += 4;
                
                // Skip value type byte
                if pos >= buffer.len() {
                    break;
                }
                let _value_type = buffer[pos];
                pos += 1;
                
                // Parse key and value
                if let Some(key) = parse_string_encoding(&buffer, &mut pos) {
                    if let Some(value) = parse_string_encoding(&buffer, &mut pos) {
                        data_store.insert(
                            key,
                            StoredValue {
                                value,
                                expires_at: Some(expire_timestamp),
                            },
                        );
                    }
                }
            }
            0xFF => {
                // End of file marker
                break;
            }
            _ => {
                // Regular key-value pair (no expiration)
                let _value_type = opcode;
                
                // Parse key and value
                if let Some(key) = parse_string_encoding(&buffer, &mut pos) {
                    if let Some(value) = parse_string_encoding(&buffer, &mut pos) {
                        data_store.insert(
                            key,
                            StoredValue {
                                value,
                                expires_at: None,
                            },
                        );
                    }
                }
            }
        }
    }
    
    data_store // Return restored data
}

// Command line argument parser
fn parse_args() -> Config {
    let args: Vec<String> = env::args().collect();
    
    // Default configuration values
    let mut dir = "/tmp/redis-data".to_string();
    let mut dbfilename = "dump.rdb".to_string();
    let mut port = 6379u16;
    let mut replicaof = None;
    
    let mut i = 1;
    while i < args.len() {
        match args[i].as_str() {
            "--dir" => {
                // Set RDB file directory
                if i + 1 < args.len() {
                    dir = args[i + 1].clone();
                    i += 2;
                } else {
                    i += 1;
                }
            }
            "--dbfilename" => {
                // Set RDB filename
                if i + 1 < args.len() {
                    dbfilename = args[i + 1].clone();
                    i += 2;
                } else {
                    i += 1;
                }
            }
            "--port" => {
                // Set server port
                if i + 1 < args.len() {
                    if let Ok(parsed_port) = args[i + 1].parse::<u16>() {
                        port = parsed_port;
                    }
                    i += 2;
                } else {
                    i += 1;
                }
            }
            "--replicaof" => {
                // Configure as replica: --replicaof "host port"
                if i + 1 < args.len() {
                    let master_info = &args[i + 1];
                    let parts: Vec<&str> = master_info.split_whitespace().collect();
                    if parts.len() == 2 {
                        if let Ok(master_port) = parts[1].parse::<u16>() {
                            replicaof = Some((parts[0].to_string(), master_port));
                        }
                    }
                    i += 2;
                } else {
                    i += 1;
                }
            }
            _ => {
                i += 1;
            }
        }
    }
    
    Config { dir, dbfilename, port, replicaof }
}

// Main server function
fn main() {
    // Parse command line arguments and configure server
    let config = parse_args();
    let bind_address = format!("127.0.0.1:{}", config.port);
    let listener = TcpListener::bind(&bind_address).unwrap();
    
    // Load existing data from RDB file
    let initial_data = load_rdb_file(&config);
    
    // Create thread-safe shared storage
    let data_store = Arc::new(Mutex::new(initial_data));

    // Accept incoming connections
    for stream in listener.incoming() {
        match stream {
            Ok(mut stream) => {
                // Clone shared resources for this connection
                let store_clone = Arc::clone(&data_store);
                let config_clone = config.clone();
                
                // Spawn thread to handle this client
                thread::spawn(move || {
                    let mut buffer = [0; 1024]; // Buffer for incoming data
                    
                    // Handle client requests in a loop
                    loop {
                        match stream.read(&mut buffer) {
                            Ok(0) => break, // Client disconnected
                            Ok(n) => {
                                // Try to parse Redis command
                                if let Some(args) = parse_redis_command(&buffer, n) {
                                    if !args.is_empty() {
                                        let command = args[0].to_uppercase();
                                        
                                        // Execute command based on type
                                        match command.as_str() {
                                            "PING" => {
                                                // Simple ping-pong response
                                                stream.write_all(b"+PONG\r\n").unwrap();
                                            }
                                            "ECHO" => {
                                                // Echo back the argument
                                                if args.len() > 1 {
                                                    let arg = &args[1];
                                                    let response = format!("${}\r\n{}\r\n", arg.len(), arg);
                                                    stream.write_all(response.as_bytes()).unwrap();
                                                }
                                            }
                                            "SET" => {
                                                // Store key-value pair with optional expiration
                                                if args.len() >= 3 {
                                                    let key = &args[1];
                                                    let value = &args[2];
                                                    let mut expires_at = None;
                                                    
                                                    // Check for PX option (millisecond expiration)
                                                    if args.len() >= 5 {
                                                        let option = args[3].to_uppercase();
                                                        if option == "PX" {
                                                            if let Ok(ms) = args[4].parse::<u128>() {
                                                                let now = SystemTime::now()
                                                                    .duration_since(UNIX_EPOCH)
                                                                    .unwrap()
                                                                    .as_millis();
                                                                expires_at = Some(now + ms);
                                                            }
                                                        }
                                                    }
                                                    
                                                    let stored_value = StoredValue {
                                                        value: value.clone(),
                                                        expires_at,
                                                    };
                                                    
                                                    // Store in shared data structure
                                                    let mut store = store_clone.lock().unwrap();
                                                    store.insert(key.clone(), stored_value);
                                                    stream.write_all(b"+OK\r\n").unwrap();
                                                }
                                            }
                                            "GET" => {
                                                // Retrieve key value with expiration check
                                                if args.len() >= 2 {
                                                    let key = &args[1];
                                                    let mut store = store_clone.lock().unwrap();
                                                    
                                                    match store.get(key) {
                                                        Some(stored_value) => {
                                                            // Check if key has expired
                                                            if let Some(expires_at) = stored_value.expires_at {
                                                                let now = SystemTime::now()
                                                                    .duration_since(UNIX_EPOCH)
                                                                    .unwrap()
                                                                    .as_millis();
                                                                
                                                                if now >= expires_at {
                                                                    // Key expired, remove and return null
                                                                    store.remove(key);
                                                                    stream.write_all(b"$-1\r\n").unwrap();
                                                                } else {
                                                                    // Key valid, return value
                                                                    let response = format!("${}\r\n{}\r\n", stored_value.value.len(), stored_value.value);
                                                                    stream.write_all(response.as_bytes()).unwrap();
                                                                }
                                                            } else {
                                                                // No expiration, return value
                                                                let response = format!("${}\r\n{}\r\n", stored_value.value.len(), stored_value.value);
                                                                stream.write_all(response.as_bytes()).unwrap();
                                                            }
                                                        }
                                                        None => {
                                                            // Key not found
                                                            stream.write_all(b"$-1\r\n").unwrap();
                                                        }
                                                    }
                                                }
                                            }
                                            "CONFIG" => {
                                                // Return configuration values
                                                if args.len() >= 3 && args[1].to_uppercase() == "GET" {
                                                    let param = &args[2];
                                                    match param.to_lowercase().as_str() {
                                                        "dir" => {
                                                            // Return directory configuration
                                                            let response = format!("*2\r\n$3\r\ndir\r\n${}\r\n{}\r\n", 
                                                                config_clone.dir.len(), config_clone.dir);
                                                            stream.write_all(response.as_bytes()).unwrap();
                                                        }
                                                        "dbfilename" => {
                                                            // Return filename configuration
                                                            let response = format!("*2\r\n$10\r\ndbfilename\r\n${}\r\n{}\r\n", 
                                                                config_clone.dbfilename.len(), config_clone.dbfilename);
                                                            stream.write_all(response.as_bytes()).unwrap();
                                                        }
                                                        _ => {
                                                            // Unknown configuration parameter
                                                            stream.write_all(b"*0\r\n").unwrap();
                                                        }
                                                    }
                                                }
                                            }
                                            "KEYS" => {
                                                // Return keys matching pattern
                                                if args.len() >= 2 {
                                                    let pattern = &args[1];
                                                    let store = store_clone.lock().unwrap();
                                                    let now = SystemTime::now()
                                                        .duration_since(UNIX_EPOCH)
                                                        .unwrap()
                                                        .as_millis();
                                                    
                                                    let mut matching_keys = Vec::new();
                                                    
                                                    // Find all non-expired keys matching pattern
                                                    for (key, stored_value) in store.iter() {
                                                        // Check if key has expired
                                                        let is_expired = if let Some(expires_at) = stored_value.expires_at {
                                                            now >= expires_at
                                                        } else {
                                                            false
                                                        };
                                                        
                                                        // Add to results if not expired and matches pattern
                                                        if !is_expired && matches_pattern(key, pattern) {
                                                            matching_keys.push(key.clone());
                                                        }
                                                    }
                                                    
                                                    // Format response as array
                                                    let mut response = format!("*{}\r\n", matching_keys.len());
                                                    for key in matching_keys {
                                                        response.push_str(&format!("${}\r\n{}\r\n", key.len(), key));
                                                    }
                                                    stream.write_all(response.as_bytes()).unwrap();
                                                } else {
                                                    // No pattern provided, return empty array
                                                    stream.write_all(b"*0\r\n").unwrap();
                                                }
                                            }
                                            "INFO" => {
                                                // Return server information
                                                if args.len() >= 2 && args[1].to_lowercase() == "replication" {
                                                    // Determine server role
                                                    let role = if config_clone.replicaof.is_some() {
                                                        "slave"  // This server is a replica
                                                    } else {
                                                        "master" // This server is a master
                                                    };
                                                    
                                                    let mut info_lines = vec![format!("role:{}", role)];
                                                    
                                                    // Add master-specific replication information
                                                    if config_clone.replicaof.is_none() {
                                                        // Master replication ID (40-character identifier)
                                                        info_lines.push("master_replid:8371b4fb1155b71f4a04d3e1bc3e18c4a990aeeb".to_string());
                                                        // Master replication offset (tracks replication stream position)
                                                        info_lines.push("master_repl_offset:0".to_string());
                                                    }
                                                    
                                                    // Join all info lines with CRLF
                                                    let info_response = info_lines.join("\r\n");
                                                    let response = format!("${}\r\n{}\r\n", info_response.len(), info_response);
                                                    stream.write_all(response.as_bytes()).unwrap();
                                                }
                                            }
                                            _ => {
                                                // Unknown command, default to PONG
                                                stream.write_all(b"+PONG\r\n").unwrap();
                                            }
                                        }
                                    }
                                } else {
                                    // Couldn't parse command, default to PONG
                                    stream.write_all(b"+PONG\r\n").unwrap();
                                }
                            }
                            Err(e) => {
                                // Error reading from client
                                println!("error reading from stream: {}", e);
                                break;
                            }
                        }
                    }
                });
            }
            Err(e) => {
                // Error accepting connection
                println!("error: {}", e);
            }
        }
    }
}
```

=== KEY TECHNICAL FEATURES ===

**1. Multi-threaded Architecture**
- Main thread listens for connections
- Each client gets a dedicated thread
- Thread-safe shared storage using `Arc<Mutex<HashMap>>`
- Concurrent request processing without blocking

**2. Redis RESP Protocol Implementation**
- Parses array format: `*N\r\n$L\r\nstring\r\n...`
- Handles bulk strings with length prefixes
- Supports all basic Redis command formats
- Proper error handling for malformed requests

**3. Data Storage with TTL Support**
- `StoredValue` struct with optional expiration
- Millisecond-precision timestamps using `SystemTime`
- Automatic cleanup during GET operations
- Memory-efficient storage with HashMap backing

**4. RDB Persistence (Read-only)**
- Binary file format parsing
- Length and string encoding support
- Multiple expiration formats (seconds, milliseconds)
- Graceful handling of corrupted/missing files
- Automatic data restoration on startup

**5. Replication Role Management**
- Master/slave role determination via `--replicaof` flag
- INFO command reports role and replication state
- Master servers include:
  - `master_replid`: 40-character unique identifier
  - `master_repl_offset`: Replication stream position (starts at 0)
- Slave servers report only role information

**6. Command Implementation**
- **PING**: Basic connectivity test
- **ECHO**: Argument reflection
- **SET/GET**: Key-value storage with optional TTL
- **CONFIG GET**: Configuration parameter retrieval
- **KEYS**: Pattern-based key enumeration
- **INFO**: Server status and replication information

**7. Configuration System**
- Command-line argument parsing
- Configurable port, directory, filename
- Replica configuration with master host/port
- Default values for all parameters

**8. Error Handling and Resilience**
- Graceful degradation for parsing errors
- Default responses for unknown commands
- File I/O error handling
- Thread-safe operations with proper locking

**9. Performance Considerations**
- O(1) key lookups in HashMap
- Minimal lock contention with quick operations
- Thread-per-connection model for moderate concurrency
- Efficient memory usage with clone-on-need

**10. Protocol Compliance**
- Correct RESP formatting for all responses
- Proper bulk string and array encoding
- Standard Redis error responses
- Compatible with redis-cli and other clients

This implementation provides a solid foundation for a Redis-compatible server with proper replication role support, persistence capabilities, and multi-threaded client handling.