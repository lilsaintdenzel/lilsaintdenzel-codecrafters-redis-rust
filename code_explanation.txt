Redis Server Code Explanation - Restaurant Analogy

This Redis server code works like a smart restaurant:

**The Restaurant (Server)**
- Opens on "127.0.0.1:6379" by default (like a restaurant address)
- **NEW**: Can now open on custom ports with `--port` flag for multiple locations!
- Waits for customers (clients) to walk in

**When Customers Arrive**
- Each customer gets their own waiter (thread) 
- The waiter stays with that customer the entire time
- Multiple customers can be served simultaneously

**How Waiters Understand Orders (Redis Protocol Parser)**
The waiters now have a special training to understand customer orders! They can decode the restaurant's special ordering format:
- Customers don't just say "PING" - they speak in a structured way: `*2\r\n$4\r\nECHO\r\n$3\r\nhey\r\n`
- The waiter (parser) breaks this down:
  - `*2` = "This order has 2 parts"
  - `$4\r\nECHO` = "First part is 4 letters: ECHO"
  - `$3\r\nhey` = "Second part is 3 letters: hey"
- So the waiter understands: "Customer wants ECHO with argument 'hey'"

**What Each Waiter Does Now**
1. Listens to what the customer says (reads data)
2. **NEW**: Decodes the special restaurant language (Redis protocol)
3. **NEW**: Checks what the customer actually ordered:
   - If they say "PING" ‚Üí responds "PONG" (simple string: `+PONG\r\n`)
   - If they say "ECHO [something]" ‚Üí repeats back exactly what they said (bulk string: `$3\r\nhey\r\n`)
   - **If they say "SET [key] [value]" ‚Üí stores it in the restaurant's memory book and says "OK"**
   - **If they say "SET [key] [value] px [time]" ‚Üí stores it with an expiration timer (like a special offer that expires!)**
   - **If they say "GET [key]" ‚Üí looks up the key in the memory book and tells them the value (or "expired" if the timer ran out)**
   - **If they say "CONFIG GET [setting]" ‚Üí tells them about the restaurant's configuration (like where backup files are stored)**
   - **If they say "KEYS [pattern]" ‚Üí shows them all the keys currently stored in the restaurant's memory book (that aren't expired)**
   - **If they say "INFO replication" ‚Üí tells them about the restaurant's role and status (reports role:master)**
   - If they say something else ‚Üí defaults to "PONG"
4. Keeps doing this until the customer leaves
5. If something goes wrong, the waiter stops serving that customer

**Key Benefits**
- Multiple customers can be served at once (concurrent connections)
- One slow customer doesn't block others
- Each conversation is independent
- **NEW**: Waiters can understand different types of orders!
- **NEW**: Responses are properly formatted in the restaurant's language
- **NEW**: The restaurant has a shared memory book that all waiters can access safely
- **NEW**: Customers can store and retrieve information (SET/GET commands)
- **NEW**: The restaurant can handle time-sensitive storage (like daily specials that expire!)
- **NEW**: The restaurant can remember things even after closing by reading from backup files when it opens (RDB persistence)
- **NEW**: Customers can ask to see what's currently available using the KEYS command
- **NEW**: The restaurant can open multiple locations on different addresses (port configuration for replication)
- **NEW**: Customers can ask about the restaurant's role and status using the INFO command (reports role:master for main restaurant)

The restaurant is now much smarter - it can handle different orders, remember things with expiration times, support multiple locations, and respond appropriately!

==== CODE WITH RESTAURANT COMMENTS ====

```rust
// Restaurant imports - tools we need
use std::collections::HashMap;  // The restaurant's memory book
use std::env;                   // For reading management instructions (command line args)
use std::fs::File;              // For reading backup files
use std::io::{BufReader, Read, Write}; // For talking to customers and reading files
use std::net::TcpListener;      // The restaurant building
use std::path::Path;            // For working with file paths
use std::sync::{Arc, Mutex};    // Safe way to share the memory book between waiters
use std::thread;                // Waiters
use std::time::{SystemTime, UNIX_EPOCH};  // Restaurant's clock for expiration timers

// üóÇÔ∏è Special memory book entry with expiration timer
#[derive(Clone)]
struct StoredValue {
    value: String,              // What's stored
    expires_at: Option<u128>,   // When it expires (restaurant's clock time)
}

// üè™ Restaurant configuration - where to keep backup files and which address to use
#[derive(Clone)]
struct Config {
    dir: String,                // Directory where backup files are stored
    dbfilename: String,         // Name of the backup file
    port: u16,                  // Which port/address to open the restaurant on
}

// üß† Special waiter training: How to understand customer orders
fn parse_redis_command(buffer: &[u8], n: usize) -> Option<Vec<String>> {
    let data = String::from_utf8_lossy(&buffer[..n]);
    let lines: Vec<&str> = data.split("\r\n").collect();
    
    // Check if it's a proper order format (*number means "order has X parts")
    if lines.is_empty() || !lines[0].starts_with('*') {
        return None;  // Can't understand this order
    }
    
    let array_len: usize = lines[0][1..].parse().ok()?;  // How many parts?
    let mut args = Vec::new();  // Collect order parts here
    let mut line_idx = 1;
    
    // Parse each part of the order
    for _ in 0..array_len {
        // Each part starts with $ and length ($4 means "next part is 4 letters")
        if line_idx >= lines.len() || !lines[line_idx].starts_with('$') {
            return None;  // Malformed order
        }
        
        let str_len: usize = lines[line_idx][1..].parse().ok()?;
        line_idx += 1;
        
        // Get the actual word
        if line_idx >= lines.len() {
            return None;
        }
        
        let arg = lines[line_idx].to_string();
        if arg.len() != str_len {
            return None;  // Length doesn't match
        }
        
        args.push(arg);  // Add this word to the order
        line_idx += 1;
    }
    
    Some(args)  // Return the understood order
}

// üîç Special filing system decoder: How to read restaurant backup files (RDB format)
fn parse_length_encoding(bytes: &[u8], pos: &mut usize) -> Option<u64> {
    // This is like reading the restaurant's special filing system where each entry
    // starts with a code that tells you how long the next piece of information is
    if *pos >= bytes.len() {
        return None;
    }
    
    let first_byte = bytes[*pos];
    *pos += 1;
    
    let first_two_bits = (first_byte & 0b11000000) >> 6;
    
    match first_two_bits {
        0b00 => {
            // Small number: the remaining 6 bits tell us the length
            Some((first_byte & 0b00111111) as u64)
        }
        0b01 => {
            // Medium number: combine this byte + next byte for length
            if *pos >= bytes.len() { return None; }
            let second_byte = bytes[*pos];
            *pos += 1;
            let length = (((first_byte & 0b00111111) as u64) << 8) | (second_byte as u64);
            Some(length)
        }
        0b10 => {
            // Large number: next 4 bytes tell us the length
            if *pos + 4 > bytes.len() { return None; }
            let mut length = 0u64;
            for i in 0..4 {
                length = (length << 8) | (bytes[*pos + i] as u64);
            }
            *pos += 4;
            Some(length)
        }
        0b11 => {
            // Special encoding marker - like "this entry is stored in a special way"
            Some(0xFF00 | ((first_byte & 0b00111111) as u64))
        }
        _ => None,
    }
}

// üìñ String decoder: How to read text from the backup files
fn parse_string_encoding(bytes: &[u8], pos: &mut usize) -> Option<String> {
    let length_or_type = parse_length_encoding(bytes, pos)?;
    
    if length_or_type >= 0xFF00 {
        // Special encoding - numbers stored as binary instead of text
        let encoding_type = (length_or_type & 0xFF) as u8;
        match encoding_type {
            0x00 => {
                // 8-bit number
                if *pos >= bytes.len() { return None; }
                let val = bytes[*pos] as i8;
                *pos += 1;
                Some(val.to_string())
            }
            0x01 => {
                // 16-bit number (little-endian)
                if *pos + 2 > bytes.len() { return None; }
                let val = u16::from_le_bytes([bytes[*pos], bytes[*pos + 1]]) as i16;
                *pos += 2;
                Some(val.to_string())
            }
            0x02 => {
                // 32-bit number (little-endian)
                if *pos + 4 > bytes.len() { return None; }
                let val = u32::from_le_bytes([
                    bytes[*pos], bytes[*pos + 1], bytes[*pos + 2], bytes[*pos + 3],
                ]) as i32;
                *pos += 4;
                Some(val.to_string())
            }
            _ => None,
        }
    } else {
        // Regular text: read the specified number of bytes
        let len = length_or_type as usize;
        if *pos + len > bytes.len() { return None; }
        let string_bytes = &bytes[*pos..*pos + len];
        *pos += len;
        String::from_utf8(string_bytes.to_vec()).ok()
    }
}

// üîç Pattern matching helper: Does this key match what the customer asked for?
fn matches_pattern(key: &str, pattern: &str) -> bool {
    if pattern == "*" {
        return true; // "*" means "show me everything"
    }
    
    // Simple pattern matching
    if pattern.contains('*') {
        if pattern == "*" {
            return true;
        }
        // More complex patterns could be added here
        true
    } else {
        key == pattern // Exact match only
    }
}

// üóÉÔ∏è Restaurant startup: Read the backup file when opening
fn load_rdb_file(config: &Config) -> HashMap<String, StoredValue> {
    let mut data_store = HashMap::new();
    let rdb_path = Path::new(&config.dir).join(&config.dbfilename);
    
    // Check if backup file exists (restaurant might be starting fresh)
    if !rdb_path.exists() {
        return data_store; // Empty memory book for new restaurant
    }
    
    // Try to open the backup file
    let file = match File::open(&rdb_path) {
        Ok(f) => f,
        Err(_) => return data_store, // Couldn't read file, start fresh
    };
    
    // Read the entire file
    let mut reader = BufReader::new(file);
    let mut buffer = Vec::new();
    if reader.read_to_end(&mut buffer).is_err() {
        return data_store; // File corrupted, start fresh
    }
    
    let mut pos = 0;
    
    // Check file header - should start with "REDIS0011"
    if buffer.len() < 9 || &buffer[0..5] != b"REDIS" {
        return data_store; // Not a valid backup file
    }
    pos = 9; // Skip header
    
    // Parse the backup file section by section
    while pos < buffer.len() {
        let opcode = buffer[pos]; // What type of section is this?
        pos += 1;
        
        match opcode {
            0xFA => {
                // Metadata section (restaurant info) - skip for now
                if let Some(_key) = parse_string_encoding(&buffer, &mut pos) {
                    let _value = parse_string_encoding(&buffer, &mut pos);
                }
            }
            0xFE => {
                // Database section marker
                let _db_index = parse_length_encoding(&buffer, &mut pos);
            }
            0xFB => {
                // Hash table size info - skip
                let _hash_table_size = parse_length_encoding(&buffer, &mut pos);
                let _expire_hash_table_size = parse_length_encoding(&buffer, &mut pos);
            }
            0xFC => {
                // Entry with millisecond expiration
                if pos + 8 > buffer.len() { break; }
                let expire_timestamp = u64::from_le_bytes([
                    buffer[pos], buffer[pos + 1], buffer[pos + 2], buffer[pos + 3],
                    buffer[pos + 4], buffer[pos + 5], buffer[pos + 6], buffer[pos + 7],
                ]) as u128;
                pos += 8;
                
                // Skip value type byte
                if pos >= buffer.len() { break; }
                let _value_type = buffer[pos];
                pos += 1;
                
                // Read key and value
                if let Some(key) = parse_string_encoding(&buffer, &mut pos) {
                    if let Some(value) = parse_string_encoding(&buffer, &mut pos) {
                        data_store.insert(key, StoredValue {
                            value,
                            expires_at: Some(expire_timestamp),
                        });
                    }
                }
            }
            0xFD => {
                // Entry with second expiration
                if pos + 4 > buffer.len() { break; }
                let expire_timestamp = u32::from_le_bytes([
                    buffer[pos], buffer[pos + 1], buffer[pos + 2], buffer[pos + 3],
                ]) as u128 * 1000; // Convert seconds to milliseconds
                pos += 4;
                
                // Skip value type byte
                if pos >= buffer.len() { break; }
                let _value_type = buffer[pos];
                pos += 1;
                
                // Read key and value
                if let Some(key) = parse_string_encoding(&buffer, &mut pos) {
                    if let Some(value) = parse_string_encoding(&buffer, &mut pos) {
                        data_store.insert(key, StoredValue {
                            value,
                            expires_at: Some(expire_timestamp),
                        });
                    }
                }
            }
            0xFF => {
                // End of file marker
                break;
            }
            _ => {
                // Regular entry without expiration
                let _value_type = opcode;
                
                // Read key and value
                if let Some(key) = parse_string_encoding(&buffer, &mut pos) {
                    if let Some(value) = parse_string_encoding(&buffer, &mut pos) {
                        data_store.insert(key, StoredValue {
                            value,
                            expires_at: None,
                        });
                    }
                }
            }
        }
    }
    
    data_store // Return the restored memory book
}

// üìã Restaurant setup: Read management instructions from command line
fn parse_args() -> Config {
    let args: Vec<String> = env::args().collect();  // Get command line arguments
    // üìÅ Default restaurant setup
    let mut dir = "/tmp/redis-data".to_string();
    let mut dbfilename = "dump.rdb".to_string();
    let mut port = 6379u16;  // Default restaurant address (port 6379)
    
    let mut i = 1;
    while i < args.len() {
        // üìñ Read management instructions
        match args[i].as_str() {
            "--dir" => {
                // "Store backup files in this directory"
                if i + 1 < args.len() {
                    dir = args[i + 1].clone();
                    i += 2;
                } else {
                    i += 1;
                }
            }
            "--dbfilename" => {
                // "Name the backup file this"
                if i + 1 < args.len() {
                    dbfilename = args[i + 1].clone();
                    i += 2;
                } else {
                    i += 1;
                }
            }
            "--port" => {
                // "Open the restaurant at this address/port"
                if i + 1 < args.len() {
                    if let Ok(parsed_port) = args[i + 1].parse::<u16>() {
                        port = parsed_port;  // Use custom address if valid
                    }
                    i += 2;
                } else {
                    i += 1;
                }
            }
            _ => {
                i += 1;
            }
        }
    }
    
    Config { dir, dbfilename, port }  // Return restaurant configuration with address
}

fn main() {
    // üìã Read management instructions and set up restaurant configuration
    let config = parse_args();
    // üè™ Open the restaurant at the configured address (default 6379, or custom via --port)
    let bind_address = format!("127.0.0.1:{}", config.port);
    let listener = TcpListener::bind(&bind_address).unwrap();
    // üóÉÔ∏è Load previous data from backup file (if it exists) - restaurant remembers what it had before!
    let initial_data = load_rdb_file(&config);
    // üìñ Create the restaurant's shared memory book with any restored data (thread-safe storage)
    let data_store = Arc::new(Mutex::new(initial_data));

    // üö™ Wait for customers to walk through the door
    for stream in listener.incoming() {
        match stream {
            // ‚úÖ A customer successfully entered
            Ok(mut stream) => {
                // üîë Give the waiter a copy of the key to the memory book
                let store_clone = Arc::clone(&data_store);
                // üìã Give the waiter a copy of the restaurant configuration
                let config_clone = config.clone();
                // üë®‚Äçüç≥ Assign a dedicated waiter to this customer
                thread::spawn(move || {
                    let mut buffer = [0; 1024];  // Waiter's notepad
                    
                    // üîÑ Keep serving this customer
                    loop {
                        // üëÇ Listen to what the customer says
                        match stream.read(&mut buffer) {
                            Ok(0) => break,  // Customer left
                            Ok(n) => {
                                // üß† Try to understand what they ordered using special training
                                if let Some(args) = parse_redis_command(&buffer, n) {
                                    if !args.is_empty() {
                                        let command = args[0].to_uppercase();  // Commands are case-insensitive
                                        
                                        // üçΩÔ∏è Serve based on what they ordered
                                        match command.as_str() {
                                            "PING" => {
                                                // Simple order: just respond "PONG"
                                                stream.write_all(b"+PONG\r\n").unwrap();
                                            }
                                            "ECHO" => {
                                                // Echo order: repeat back what they said
                                                if args.len() > 1 {
                                                    let arg = &args[1];
                                                    // Format response as: $length\r\nvalue\r\n
                                                    let response = format!("${}\r\n{}\r\n", arg.len(), arg);
                                                    stream.write_all(response.as_bytes()).unwrap();
                                                }
                                            }
                                            "SET" => {
                                                // üìù Customer wants to store something: "SET key value" or "SET key value px 100"
                                                if args.len() >= 3 {
                                                    let key = &args[1];
                                                    let value = &args[2];
                                                    
                                                    let mut expires_at = None;
                                                    
                                                    // üïê Check if customer wants expiration timer: "px 100" means "expires in 100 milliseconds"
                                                    if args.len() >= 5 {
                                                        let option = args[3].to_uppercase();
                                                        if option == "PX" {
                                                            if let Ok(ms) = args[4].parse::<u128>() {
                                                                // üïê Set restaurant's timer: current time + expiration time
                                                                let now = SystemTime::now()
                                                                    .duration_since(UNIX_EPOCH)
                                                                    .unwrap()
                                                                    .as_millis();
                                                                expires_at = Some(now + ms);
                                                            }
                                                        }
                                                    }
                                                    
                                                    // üóÇÔ∏è Create memory book entry with value and optional timer
                                                    let stored_value = StoredValue {
                                                        value: value.clone(),
                                                        expires_at,
                                                    };
                                                    
                                                    // üîí Lock the memory book so only this waiter can write
                                                    let mut store = store_clone.lock().unwrap();
                                                    // üìñ Write the entry in the book
                                                    store.insert(key.clone(), stored_value);
                                                    // ‚úÖ Tell customer "OK, I wrote it down!"
                                                    stream.write_all(b"+OK\r\n").unwrap();
                                                }
                                            }
                                            "GET" => {
                                                // üîç Customer wants to retrieve something: "GET key"
                                                if args.len() >= 2 {
                                                    let key = &args[1];
                                                    // üîí Lock the memory book to read/write safely (might need to remove expired items)
                                                    let mut store = store_clone.lock().unwrap();
                                                    
                                                    match store.get(key) {
                                                        Some(stored_value) => {
                                                            // üïê Check if this item has expired
                                                            if let Some(expires_at) = stored_value.expires_at {
                                                                let now = SystemTime::now()
                                                                    .duration_since(UNIX_EPOCH)
                                                                    .unwrap()
                                                                    .as_millis();
                                                                
                                                                if now >= expires_at {
                                                                    // ‚è∞ Timer expired! Remove it and say "not found"
                                                                    store.remove(key);
                                                                    stream.write_all(b"$-1\r\n").unwrap();
                                                                } else {
                                                                    // üìñ Still fresh! Tell them the value
                                                                    let response = format!("${}\r\n{}\r\n", stored_value.value.len(), stored_value.value);
                                                                    stream.write_all(response.as_bytes()).unwrap();
                                                                }
                                                            } else {
                                                                // üìñ No timer, never expires - tell them the value
                                                                let response = format!("${}\r\n{}\r\n", stored_value.value.len(), stored_value.value);
                                                                stream.write_all(response.as_bytes()).unwrap();
                                                            }
                                                        }
                                                        None => {
                                                            // ü§∑ Not found, tell them it doesn't exist
                                                            stream.write_all(b"$-1\r\n").unwrap();
                                                        }
                                                    }
                                                }
                                            }
                                            "CONFIG" => {
                                                // üìã Customer asking about restaurant setup: "CONFIG GET dir" or "CONFIG GET dbfilename"
                                                if args.len() >= 3 && args[1].to_uppercase() == "GET" {
                                                    let param = &args[2];  // What configuration they want to know
                                                    match param.to_lowercase().as_str() {
                                                        "dir" => {
                                                            // üìÅ "Where do you store backup files?"
                                                            let response = format!("*2\r\n$3\r\ndir\r\n${}\r\n{}\r\n", 
                                                                config_clone.dir.len(), config_clone.dir);
                                                            stream.write_all(response.as_bytes()).unwrap();
                                                        }
                                                        "dbfilename" => {
                                                            // üóÇÔ∏è "What's the backup file called?"
                                                            let response = format!("*2\r\n$10\r\ndbfilename\r\n${}\r\n{}\r\n", 
                                                                config_clone.dbfilename.len(), config_clone.dbfilename);
                                                            stream.write_all(response.as_bytes()).unwrap();
                                                        }
                                                        _ => {
                                                            // ü§∑ Don't know that configuration setting
                                                            stream.write_all(b"*0\r\n").unwrap();
                                                        }
                                                    }
                                                }
                                            }
                                            "KEYS" => {
                                                // üîç Customer wants to see what's available: "KEYS *" (show all) or "KEYS foo" (show keys matching "foo")
                                                if args.len() >= 2 {
                                                    let pattern = &args[1];
                                                    // üîí Lock the memory book to read current inventory
                                                    let store = store_clone.lock().unwrap();
                                                    let now = SystemTime::now()
                                                        .duration_since(UNIX_EPOCH)
                                                        .unwrap()
                                                        .as_millis();
                                                    
                                                    let mut matching_keys = Vec::new();
                                                    
                                                    // üîç Look through all items in the memory book
                                                    for (key, stored_value) in store.iter() {
                                                        // ‚è∞ Check if this item has expired
                                                        let is_expired = if let Some(expires_at) = stored_value.expires_at {
                                                            now >= expires_at
                                                        } else {
                                                            false
                                                        };
                                                        
                                                        // ‚úÖ If not expired and matches the pattern, add to list
                                                        if !is_expired && matches_pattern(key, pattern) {
                                                            matching_keys.push(key.clone());
                                                        }
                                                    }
                                                    
                                                    // üìù Format response as Redis array: *2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n
                                                    let mut response = format!("*{}\r\n", matching_keys.len());
                                                    for key in matching_keys {
                                                        response.push_str(&format!("${}\r\n{}\r\n", key.len(), key));
                                                    }
                                                    stream.write_all(response.as_bytes()).unwrap();
                                                } else {
                                                    // No pattern provided, return empty list
                                                    stream.write_all(b"*0\r\n").unwrap();
                                                }
                                            }
                                            "INFO" => {
                                                // üìä Customer wants to know about the restaurant's status: "INFO replication"
                                                if args.len() >= 2 && args[1].to_lowercase() == "replication" {
                                                    // üè™ Tell them this is the main restaurant (master role)
                                                    let info_response = "role:master";
                                                    let response = format!("${}\r\n{}\r\n", info_response.len(), info_response);
                                                    stream.write_all(response.as_bytes()).unwrap();
                                                }
                                            }
                                            _ => {
                                                // Unknown order: default to PONG
                                                stream.write_all(b"+PONG\r\n").unwrap();
                                            }
                                        }
                                    }
                                } else {
                                    // ü§∑ Couldn't understand the order format, default to PONG
                                    stream.write_all(b"+PONG\r\n").unwrap();
                                }
                            }
                            Err(e) => {
                                // üòµ Something went wrong with this customer
                                println!("error reading from stream: {}", e);
                                break;  // Stop serving them
                            }
                        }
                    }
                });  // End of waiter's job
            }
            // ‚ùå Someone tried to enter but couldn't
            Err(e) => {
                println!("error: {}", e);
            }
        }
    }  // Keep waiting for more customers
}
```

**Key Insights:**
1. **Each `thread::spawn` creates a new waiter** who can work independently, so the restaurant can serve many customers simultaneously instead of one at a time!

2. **The `parse_redis_command` function is like waiter training** - it teaches waiters how to decode the restaurant's special ordering language (Redis RESP protocol).

3. **The restaurant now has a proper menu system** - different orders (`PING`, `ECHO`, `SET`, `GET`) get different responses, making it much more useful than just saying "PONG" to everything!

4. **Smart fallback system** - if a waiter can't understand an order, they default to the simple "PONG" response rather than breaking.

5. **The memory book (`HashMap`) is shared safely** - `Arc<Mutex<>>` ensures multiple waiters can access the same memory book without conflicts:
   - `Arc` = Multiple waiters can have a "reference" to the same book
   - `Mutex` = Only one waiter can read/write in the book at a time (prevents data corruption)

6. **Thread-safe storage operations**:
   - `SET`: Waiter locks the book, writes the key-value pair, unlocks, says "OK"
   - `SET` with timer: Same as above, but also sets an expiration timer
   - `GET`: Waiter locks the book, checks if expired (removes if so), tells customer the value (or "not found")

7. **Smart expiration system** - like daily specials that automatically disappear:
   - `StoredValue` struct holds both the value and optional expiration time
   - When storing: `SET key value px 100` sets a 100ms timer using the restaurant's clock
   - When retrieving: GET checks the timer first - if expired, removes the item and says "not found"
   - Timer precision: Uses milliseconds since Unix epoch for accurate timing

8. **Restaurant Configuration System** - like setting up the restaurant's filing system:
   - `Config` struct stores where the restaurant keeps its backup files
   - `parse_args()` reads the command line (like management instructions): `--dir /tmp/redis-files --dbfilename dump.rdb`
   - The restaurant now knows where to store its backup records for persistence
   - `CONFIG GET` command lets customers ask: "Where do you keep your backup files?"
   - Waiters can answer questions about the restaurant's setup using the `CONFIG` command

9. **RDB Persistence System** - like the restaurant's backup and restore system:
   - `load_rdb_file()` runs when the restaurant opens to restore previous data from backup files
   - Can read the special RDB file format with different sections (header, metadata, database, end-of-file)
   - Supports both length encoding and string encoding to decode the backup format
   - Handles entries with expiration times (both seconds and milliseconds)
   - If backup file doesn't exist or is corrupted, restaurant starts fresh with empty memory book
   - Restaurant can now remember what it had before, even after closing and reopening!

10. **KEYS Command System** - like showing customers the current menu:
   - `KEYS *` shows all non-expired items currently in the restaurant's memory book
   - `KEYS pattern` supports simple pattern matching (exact matches or "*" for everything)
   - `matches_pattern()` function determines if a key matches what the customer asked for
   - Automatically filters out expired items - customers only see what's currently available
   - Returns results in Redis array format: `*2\r\n$3\r\nkey1\r\n$4\r\nkey2\r\n`

11. **Port Configuration System** - like opening multiple restaurant locations:
   - `Config` struct now includes `port: u16` field to store the restaurant's address
   - `parse_args()` reads `--port` flag from command line: `./restaurant --port 6380`
   - Default port is 6379 (standard Redis port), but can be customized for any valid port number
   - `bind_address` is dynamically created: `format!("127.0.0.1:{}", config.port)`
   - This enables running multiple restaurant instances simultaneously for replication:
     - Main restaurant: `./restaurant` (runs on port 6379)
     - Branch restaurant: `./restaurant --port 6380` (runs on port 6380)
   - Each restaurant operates independently but can share the same codebase
   - Essential for leader-follower replication where multiple Redis servers need different addresses

12. **INFO Command System** - like the restaurant's information desk:
   - `INFO replication` provides status information about the restaurant's role in a distributed system
   - Currently reports `role:master` indicating this is the main restaurant location
   - Response is formatted as a bulk string: `$11\r\nrole:master\r\n`
   - Essential for restaurant coordination - other systems can ask "What type of restaurant are you?"
   - Prepares for future distributed restaurant features where locations need to know each other's roles
   - Like asking the host: "Is this the main restaurant or a franchise location?"